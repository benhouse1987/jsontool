<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON å¯¹æ¯”ç»“æœè§£æå·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.5;
        }

        .content {
            padding: 30px 40px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }

        .comparison-input {
            width: 100%;
            height: 200px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
            background: #fafafa;
        }

        .comparison-input:focus {
            outline: none;
            border-color: #4CAF50;
            background: white;
        }

        .controls {
            text-align: center;
            margin-bottom: 30px;
        }

        .btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 10px;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .parsing-info {
            background: #e8f5e8;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .parsing-info h4 {
            color: #2e7d32;
            margin-bottom: 10px;
        }

        .parsing-info .extracted-json {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
        }

        .result-section {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .result-group {
            min-width: 0;
            /* é˜²æ­¢å†…å®¹æº¢å‡º */
        }

        .result-group h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.1em;
            padding-bottom: 10px;
            border-bottom: 2px solid #4CAF50;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-display {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            min-height: 450px;
            max-height: 650px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            overflow: auto;
            line-height: 1.5;
            word-break: break-all;
            word-wrap: break-word;
            box-sizing: border-box;
        }

        .error {
            color: #f44336;
            background: #ffebee;
            border-color: #f44336;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }

        .success {
            color: #4CAF50;
            background: #e8f5e8;
            border: 2px solid #4CAF50;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        .diff-add {
            background-color: #d4edda;
            color: #155724;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .diff-remove {
            background-color: #f8d7da;
            color: #721c24;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .diff-change {
            background-color: #fff3cd;
            color: #856404;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .property-path {
            color: #6f42c1;
            font-weight: bold;
        }

        .json-key {
            color: #0066cc;
            font-weight: bold;
        }

        .json-string {
            color: #008800;
        }

        .json-number {
            color: #ff6600;
        }

        .json-boolean {
            color: #cc0066;
        }

        .json-null {
            color: #999999;
        }

        .stats {
            background: #f0f8ff;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .stats h4 {
            color: #333;
            margin-bottom: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .stat-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #4CAF50;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
        }

        .diff-add-line {
            background-color: #d4edda !important;
            border-radius: 3px;
        }

        .diff-remove-line {
            background-color: #f8d7da !important;
            border-radius: 3px;
        }

        .diff-change-line {
            background-color: #fff3cd !important;
            border-radius: 3px;
        }

        .diff-primary-key-line {
            background-color: #cce5ff !important;
            border-radius: 3px;
        }

        /* å“åº”å¼è®¾è®¡ä¼˜åŒ– */
        @media (max-width: 1600px) {
            .result-section {
                grid-template-columns: 1fr 1fr 1fr;
                gap: 15px;
            }

            .result-display {
                font-size: 11px;
                padding: 12px;
            }
        }

        @media (max-width: 1400px) {
            .container {
                max-width: 95%;
            }

            .content {
                padding: 25px 30px;
            }
        }

        @media (max-width: 1200px) {
            .result-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .result-display {
                max-height: 500px;
                min-height: 350px;
                font-size: 12px;
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .content {
                padding: 20px;
            }

            .result-display {
                font-size: 11px;
                padding: 10px;
                max-height: 400px;
                min-height: 300px;
            }

            .result-section {
                gap: 15px;
            }
        }

        /* ç¡®ä¿å·®å¼‚æŠ¥å‘Šä¹Ÿæœ‰åˆé€‚çš„å¸ƒå±€ */
        .diff-report-section {
            width: 100%;
            margin-top: 20px;
        }

        .diff-report-section .result-group {
            width: 100%;
        }

        .diff-report-section .result-display {
            max-height: 500px;
        }

        /* Toastæç¤ºæ ·å¼ */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 9999;
            font-size: 14px;
            font-weight: 500;
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.3s ease-in-out;
            max-width: 300px;
            word-wrap: break-word;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.success {
            background: #4CAF50;
            border-left: 4px solid #45a049;
        }

        .toast.error {
            background: #f44336;
            border-left: 4px solid #d32f2f;
        }

        .toast.info {
            background: #2196F3;
            border-left: 4px solid #1976D2;
        }

        .toast.warning {
            background: #ff9800;
            border-left: 4px solid #f57c00;
        }

        .toast .toast-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 16px;
        }

        .toast .toast-message {
            display: inline-block;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” JSON å“åº”å¯¹æ¯”å·¥å…·</h1>
            <p>æ™ºèƒ½è¯†åˆ«æ•°ç»„ä¸»é”®ï¼Œç²¾ç¡®é«˜äº®å·®å¼‚ä½ç½®ï¼Œä¸‰åˆ—åŒæ­¥æ»šåŠ¨å¯¹æ¯”</p>
        </div>

        <!-- **æ·»åŠ æµ‹è¯•æ¡ˆä¾‹æŒ‰é’®** -->
        <div style="margin-bottom: 20px; text-align: center;">
            <button onclick="loadTestCase()"
                style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 0 5px;">
                ğŸ“ åŠ è½½æµ‹è¯•æ¡ˆä¾‹ï¼ˆæ™®é€šå­—æ®µå·®å¼‚ï¼‰
            </button>
            <button onclick="loadBlueHighlightTestCase()"
                style="padding: 8px 16px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 0 5px;">
                ğŸ”‘ åŠ è½½æµ‹è¯•æ¡ˆä¾‹ï¼ˆä¸»é”®å­—æ®µå·®å¼‚ï¼‰
            </button>
            <button onclick="loadIgnoredTestCase()"
                style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 0 5px;">
                ğŸš« åŠ è½½æµ‹è¯•æ¡ˆä¾‹ï¼ˆå¿½ç•¥å­—æ®µæµ‹è¯•ï¼‰
            </button>
        </div>

        <div class="content">
            <div class="input-section">
                <label for="comparisonInput">è¯·è¾“å…¥è¦å¯¹æ¯”çš„å†…å®¹ï¼š</label>
                <textarea id="comparisonInput" class="comparison-input"
                    placeholder="è¯·è¾“å…¥æ ¼å¼ï¼š&#10;å®é™…å“åº”:&#10;{...}&#10;&#10;é¢„æœŸå“åº”:&#10;{...}&#10;&#10;åŸå§‹å½•åˆ¶å“åº”:&#10;{...}"></textarea>
                <div class="controls">
                    <button class="btn" onclick="parseAndCompare()">ğŸ” å¼€å§‹å¯¹æ¯”</button>
                    <button class="btn" onclick="clearAll()">ğŸ—‘ï¸ æ¸…ç©º</button>
                </div>
                <div id="parsing-info"></div>
            </div>

            <div id="comparison-stats"></div>

            <div class="result-section">
                <div class="result-group">
                    <h3>å®é™…å“åº” (æ ¼å¼åŒ–)</h3>
                    <div id="actual-result" class="result-display"></div>
                </div>
                <div class="result-group">
                    <h3>é¢„æœŸå“åº” (æ ¼å¼åŒ–)</h3>
                    <div id="expected-result" class="result-display"></div>
                </div>
                <div class="result-group">
                    <h3>åŸå§‹å½•åˆ¶å“åº”</h3>
                    <div id="original-recorded-result" class="result-display"></div>
                </div>
            </div>

            <div class="diff-report-section">
                <div class="result-group">
                    <h3>å·®å¼‚æŠ¥å‘Š</h3>
                    <div id="diff-report" class="result-display"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Toastæç¤ºå‡½æ•°
        function showToast(message, type = 'info', duration = 3000) {
            // ç§»é™¤å·²å­˜åœ¨çš„toast
            const existingToast = document.querySelector('.toast');
            if (existingToast) {
                existingToast.remove();
            }

            // åˆ›å»ºæ–°çš„toast
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            // æ ¹æ®ç±»å‹è®¾ç½®å›¾æ ‡
            let icon = '';
            switch(type) {
                case 'success':
                    icon = 'âœ…';
                    break;
                case 'error':
                    icon = 'âŒ';
                    break;
                case 'warning':
                    icon = 'âš ï¸';
                    break;
                case 'info':
                default:
                    icon = 'â„¹ï¸';
                    break;
            }

            toast.innerHTML = `
                <span class="toast-icon">${icon}</span>
                <span class="toast-message">${message}</span>
            `;

            // æ·»åŠ åˆ°é¡µé¢
            document.body.appendChild(toast);

            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);

            // è‡ªåŠ¨éšè—
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, duration);
        }

        function parseComparisonResult(inputText) {
            const result = {
                actualResponse: null,
                expectedResponse: null,
                originalRecordedResponse: null, // æ–°å¢å­—æ®µ
                parseSuccess: false,
                errors: []
            };

            try {
                // **æ”¹è¿›ï¼šæ›´å¥½åœ°å¤„ç†è¢«åŒå¼•å·åŒ…è£¹çš„å†…å®¹**
                let cleanedInput = inputText.trim();
                
                // æ£€æŸ¥æ˜¯å¦æ•´ä¸ªå†…å®¹è¢«åŒå¼•å·åŒ…è£¹
                if (cleanedInput.startsWith('"') && cleanedInput.endsWith('"')) {
                    console.log('æ£€æµ‹åˆ°è¾“å…¥è¢«åŒå¼•å·åŒ…è£¹ï¼Œæ­£åœ¨å»é™¤...');
                    cleanedInput = cleanedInput.slice(1, -1);
                    
                    // å¤„ç†å†…éƒ¨çš„è½¬ä¹‰å­—ç¬¦
                    cleanedInput = cleanedInput
                        .replace(/\\"/g, '"')           // è½¬ä¹‰çš„åŒå¼•å·
                        .replace(/\\n/g, '\n')          // è½¬ä¹‰çš„æ¢è¡Œç¬¦
                        .replace(/\\r/g, '\r')          // è½¬ä¹‰çš„å›è½¦ç¬¦
                        .replace(/\\t/g, '\t')          // è½¬ä¹‰çš„åˆ¶è¡¨ç¬¦
                        .replace(/\\\\/g, '\\');        // è½¬ä¹‰çš„åæ–œæ 
                    
                    console.log('å»é™¤åŒå¼•å·åçš„å†…å®¹é•¿åº¦:', cleanedInput.length);
                }

                // æŸ¥æ‰¾å®é™…å“åº”
                const actualMatch = cleanedInput.match(/å®é™…å“åº”:\s*\n([\s\S]*?)(?=\n\s*é¢„æœŸå“åº”:|$)/i);
                if (actualMatch) {
                    result.actualResponse = actualMatch[1].trim();
                } else {
                    result.errors.push('æœªæ‰¾åˆ°"å®é™…å“åº”"éƒ¨åˆ†');
                }

                // æŸ¥æ‰¾é¢„æœŸå“åº” - æ”¹è¿›çš„æ­£åˆ™è¡¨è¾¾å¼
                const expectedMatch = cleanedInput.match(/é¢„æœŸå“åº”:\s*\n([\s\S]*?)(?=\n\s*åŸå§‹å½•åˆ¶å“åº”:|$)/i);
                if (expectedMatch) {
                    let expectedText = expectedMatch[1].trim();

                    // å°è¯•æ‰¾åˆ°JSONçš„ç»“æŸä½ç½®
                    const jsonEnd = findJsonEnd(expectedText);
                    if (jsonEnd !== -1) {
                        expectedText = expectedText.substring(0, jsonEnd + 1);
                    }

                    result.expectedResponse = expectedText;
                } else {
                    result.errors.push('æœªæ‰¾åˆ°"é¢„æœŸå“åº”"éƒ¨åˆ†');
                }

                // æŸ¥æ‰¾åŸå§‹å½•åˆ¶å“åº”
                const originalRecordedMatch = cleanedInput.match(/åŸå§‹å½•åˆ¶å“åº”:\s*\n([\s\S]*?)(?=\n|$)/i);
                if (originalRecordedMatch) {
                    let originalRecordedText = originalRecordedMatch[1].trim();

                    // å°è¯•æ‰¾åˆ°JSONçš„ç»“æŸä½ç½®
                    const originalRecordedJsonEnd = findJsonEnd(originalRecordedText);
                    if (originalRecordedJsonEnd !== -1) {
                        originalRecordedText = originalRecordedText.substring(0, originalRecordedJsonEnd + 1);
                    }

                    result.originalRecordedResponse = originalRecordedText;
                } else {
                    result.errors.push('æœªæ‰¾åˆ°"åŸå§‹å½•åˆ¶å“åº”"éƒ¨åˆ†');
                }

                result.parseSuccess = result.actualResponse && result.expectedResponse && result.originalRecordedResponse;
                return result;
            } catch (error) {
                result.errors.push(`è§£æé”™è¯¯: ${error.message}`);
                return result;
            }
        }

        // æ–°å¢å‡½æ•°ï¼šæŸ¥æ‰¾JSONçš„ç»“æŸä½ç½®
        function findJsonEnd(text) {
            let braceCount = 0;
            let bracketCount = 0;
            let inString = false;
            let escaped = false;
            let jsonStarted = false;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];

                if (escaped) {
                    escaped = false;
                    continue;
                }

                if (char === '\\') {
                    escaped = true;
                    continue;
                }

                if (char === '"') {
                    inString = !inString;
                    continue;
                }

                if (inString) {
                    continue;
                }

                if (char === '{') {
                    braceCount++;
                    jsonStarted = true;
                } else if (char === '}') {
                    braceCount--;
                    if (jsonStarted && braceCount === 0 && bracketCount === 0) {
                        return i; // è¿”å›JSONç»“æŸçš„ä½ç½®
                    }
                } else if (char === '[') {
                    bracketCount++;
                    jsonStarted = true;
                } else if (char === ']') {
                    bracketCount--;
                    if (jsonStarted && bracketCount === 0 && braceCount === 0) {
                        return i; // è¿”å›JSONç»“æŸçš„ä½ç½®
                    }
                }
            }

            return -1; // æ²¡æœ‰æ‰¾åˆ°å®Œæ•´çš„JSON
        }

        function unescapeJSON(str) {
            try {
                // é¦–å…ˆæ¸…ç†å­—ç¬¦ä¸²ï¼šå»æ‰é¦–å°¾ç©ºç™½
                let cleaned = str.trim();
                console.log('unescapeJSON - åŸå§‹è¾“å…¥é•¿åº¦:', cleaned.length);
                console.log('unescapeJSON - åŸå§‹è¾“å…¥å‰100å­—ç¬¦:', cleaned.substring(0, 100));

                // å»æ‰æ–‡æœ¬å†…å®¹æœ€åä¸€ä¸ªåŒå¼•å·ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (cleaned.endsWith('"')) {
                    cleaned = cleaned.slice(0, -1);
                    console.log('unescapeJSON - å»æ‰ç»“å°¾åŒå¼•å·åé•¿åº¦:', cleaned.length);
                }

                // å¦‚æœå¼€å¤´ä¹Ÿæœ‰åŒå¼•å·ï¼Œä¹Ÿå»æ‰
                if (cleaned.startsWith('"')) {
                    cleaned = cleaned.slice(1);
                    console.log('unescapeJSON - å»æ‰å¼€å¤´åŒå¼•å·åé•¿åº¦:', cleaned.length);
                }

                // é¦–å…ˆå°è¯•ç›´æ¥è§£æï¼Œå¦‚æœæˆåŠŸè¯´æ˜ä¸éœ€è¦å¤„ç†è½¬ä¹‰
                try {
                    const parsed = JSON.parse(cleaned);
                    console.log('unescapeJSON - ç›´æ¥è§£ææˆåŠŸï¼Œæ— éœ€è½¬ä¹‰å¤„ç†');
                    return cleaned;
                } catch (e) {
                    // è§£æå¤±è´¥ï¼Œç»§ç»­å¤„ç†è½¬ä¹‰å­—ç¬¦
                    console.log('unescapeJSON - ç›´æ¥è§£æå¤±è´¥ï¼Œå¼€å§‹å¤„ç†è½¬ä¹‰å­—ç¬¦:', e.message);
                    console.log('unescapeJSON - é”™è¯¯ä½ç½®:', e.message.match(/position (\d+)/)?.[1]);
                }

                let result = cleaned;

                // **æ”¹è¿›ï¼šæ›´å…¨é¢çš„è½¬ä¹‰å­—ç¬¦å¤„ç†**
                // å¤„ç†å¸¸è§çš„è½¬ä¹‰å­—ç¬¦ï¼ŒæŒ‰ç…§æ­£ç¡®çš„é¡ºåºå¤„ç†
                result = result
                    .replace(/\\u([0-9a-fA-F]{4})/g, (match, code) => {
                        return String.fromCharCode(parseInt(code, 16));
                    })                               // \uXXXX -> Unicodeå­—ç¬¦ (å…ˆå¤„ç†ï¼Œé¿å…è¢«å…¶ä»–è§„åˆ™å½±å“)
                    .replace(/\\\\/g, '\x00')        // ä¸´æ—¶æ›¿æ¢ \\ ä¸ºç‰¹æ®Šå­—ç¬¦ï¼Œé¿å…å¹²æ‰°
                    .replace(/\\"/g, '"')            // \" -> "
                    .replace(/\\n/g, '\n')           // \n -> æ¢è¡Œ
                    .replace(/\\r/g, '\r')           // \r -> å›è½¦
                    .replace(/\\t/g, '\t')           // \t -> åˆ¶è¡¨ç¬¦
                    .replace(/\\b/g, '\b')           // \b -> é€€æ ¼
                    .replace(/\\f/g, '\f')           // \f -> æ¢é¡µ
                    .replace(/\\\//g, '/')           // \/ -> /
                    .replace(/\x00/g, '\\');         // æ¢å¤ \\ -> \

                console.log('unescapeJSON - ç¬¬ä¸€æ¬¡è½¬ä¹‰å¤„ç†åå‰100å­—ç¬¦:', result.substring(0, 100));

                // å°è¯•è§£æå¤„ç†åçš„ç»“æœ
                try {
                    const parsed = JSON.parse(result);
                    console.log('unescapeJSON - ç¬¬ä¸€æ¬¡è½¬ä¹‰å¤„ç†åè§£ææˆåŠŸ');
                    return result;
                } catch (e) {
                    console.log('unescapeJSON - ç¬¬ä¸€æ¬¡è½¬ä¹‰å¤„ç†å¤±è´¥ï¼Œå°è¯•å¤šé‡è½¬ä¹‰å¤„ç†:', e.message);
                    console.log('unescapeJSON - é”™è¯¯ä½ç½®:', e.message.match(/position (\d+)/)?.[1]);
                    
                    // å°è¯•å¤„ç†å¤šé‡è½¬ä¹‰ï¼ˆå¯èƒ½æ˜¯å¤šæ¬¡ç¼–ç å¯¼è‡´çš„ï¼‰
                    let doubleUnescaped = result
                        .replace(/\\\\u([0-9a-fA-F]{4})/g, (match, code) => {
                            return String.fromCharCode(parseInt(code, 16));
                        })
                        .replace(/\\\\\\\\/g, '\x00')    // ä¸´æ—¶æ›¿æ¢ \\\\ ä¸ºç‰¹æ®Šå­—ç¬¦
                        .replace(/\\\\"/g, '"')          // \\" -> "
                        .replace(/\\\\n/g, '\n')         // \\n -> \n
                        .replace(/\\\\r/g, '\r')         // \\r -> \r
                        .replace(/\\\\t/g, '\t')         // \\t -> \t
                        .replace(/\\\\b/g, '\b')         // \\b -> \b
                        .replace(/\\\\f/g, '\f')         // \\f -> \f
                        .replace(/\\\\\//g, '/')         // \\/ -> /
                        .replace(/\x00/g, '\\');         // æ¢å¤ \\\\ -> \\

                    console.log('unescapeJSON - å¤šé‡è½¬ä¹‰å¤„ç†åå‰100å­—ç¬¦:', doubleUnescaped.substring(0, 100));

                    try {
                        const parsed = JSON.parse(doubleUnescaped);
                        console.log('unescapeJSON - å¤šé‡è½¬ä¹‰å¤„ç†åè§£ææˆåŠŸ');
                        return doubleUnescaped;
                    } catch (e) {
                        console.log('unescapeJSON - å¤šé‡è½¬ä¹‰å¤„ç†ä¹Ÿå¤±è´¥ï¼Œå°è¯•ä¿®å¤å¸¸è§çš„JSONæ ¼å¼é—®é¢˜:', e.message);
                        console.log('unescapeJSON - é”™è¯¯ä½ç½®:', e.message.match(/position (\d+)/)?.[1]);
                        
                        // å°è¯•ä¿®å¤ä¸€äº›å¸¸è§çš„JSONæ ¼å¼é—®é¢˜
                        let fixedResult = doubleUnescaped;
                        
                        // ä¿®å¤å¯èƒ½çš„å°¾éšé€—å·é—®é¢˜
                        fixedResult = fixedResult.replace(/,(\s*[}\]])/g, '$1');
                        
                        // ä¿®å¤å¯èƒ½çš„å•å¼•å·é—®é¢˜
                        fixedResult = fixedResult.replace(/'/g, '"');
                        
                        // ä¿®å¤å¯èƒ½çš„å±æ€§åæ²¡æœ‰å¼•å·çš„é—®é¢˜
                        fixedResult = fixedResult.replace(/([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g, '$1"$2":');
                        
                        // **æ–°å¢ï¼šå°è¯•ä¿®å¤è¢«æˆªæ–­çš„JSON**
                        // å¦‚æœJSONçœ‹èµ·æ¥è¢«æˆªæ–­äº†ï¼Œå°è¯•è¡¥å…¨
                        if (fixedResult.trim() && !fixedResult.trim().endsWith('}') && !fixedResult.trim().endsWith(']')) {
                            console.log('unescapeJSON - æ£€æµ‹åˆ°å¯èƒ½è¢«æˆªæ–­çš„JSONï¼Œå°è¯•è¡¥å…¨');
                            // ç»Ÿè®¡æœªé—­åˆçš„æ‹¬å·
                            let openBraces = (fixedResult.match(/\{/g) || []).length;
                            let closeBraces = (fixedResult.match(/\}/g) || []).length;
                            let openBrackets = (fixedResult.match(/\[/g) || []).length;
                            let closeBrackets = (fixedResult.match(/\]/g) || []).length;
                            
                            console.log(`unescapeJSON - æ‹¬å·ç»Ÿè®¡: { ${openBraces} vs } ${closeBraces}, [ ${openBrackets} vs ] ${closeBrackets}`);
                            
                            // è¡¥å…¨ç¼ºå¤±çš„æ‹¬å·
                            for (let i = 0; i < openBraces - closeBraces; i++) {
                                fixedResult += '}';
                            }
                            for (let i = 0; i < openBrackets - closeBrackets; i++) {
                                fixedResult += ']';
                            }
                            
                            console.log('unescapeJSON - è¡¥å…¨æ‹¬å·åçš„ç»“æœé•¿åº¦:', fixedResult.length);
                        }
                        
                        try {
                            const parsed = JSON.parse(fixedResult);
                            console.log('unescapeJSON - JSONæ ¼å¼ä¿®å¤åè§£ææˆåŠŸ');
                            return fixedResult;
                        } catch (e) {
                            console.log('unescapeJSON - æ‰€æœ‰ä¿®å¤å°è¯•éƒ½å¤±è´¥ï¼Œè¿”å›æœ€åå¤„ç†çš„ç»“æœ:', e.message);
                            console.log('unescapeJSON - æœ€ç»ˆç»“æœå‰100å­—ç¬¦:', fixedResult.substring(0, 100));
                            console.log('unescapeJSON - æœ€ç»ˆç»“æœå100å­—ç¬¦:', fixedResult.substring(Math.max(0, fixedResult.length - 100)));
                            
                            // **æ–°å¢ï¼šæœ€åå°è¯• - å¦‚æœæ˜¯å› ä¸ºä½ç½®68çš„é—®é¢˜ï¼Œå°è¯•æ‰‹åŠ¨ä¿®å¤**
                            if (e.message.includes('position 68') || e.message.includes('position')) {
                                console.log('unescapeJSON - å°è¯•æ‰‹åŠ¨ä¿®å¤ä½ç½®ç›¸å…³çš„JSONé”™è¯¯');
                                // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šç‰¹å®šçš„ä¿®å¤é€»è¾‘
                            }
                            
                            return fixedResult;
                        }
                    }
                }
            } catch (e) {
                console.log('unescapeJSON - å‡½æ•°å¼‚å¸¸:', e.message);
                return str;
            }
        }

        function sortObjectKeys(obj) {
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }

            if (Array.isArray(obj)) {
                // å¯¹æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ é€’å½’æ’åº
                const sortedArray = obj.map(item => sortObjectKeys(item));

                // å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œç›´æ¥è¿”å›
                if (sortedArray.length === 0) {
                    return sortedArray;
                }

                // æ£€æŸ¥æ•°ç»„ä¸­å…ƒç´ çš„ç±»å‹
                const hasObjects = sortedArray.some(item => typeof item === 'object' && item !== null && !Array.isArray(item));
                const hasArrays = sortedArray.some(item => Array.isArray(item));
                const hasPrimitives = sortedArray.some(item => typeof item !== 'object' || item === null);

                // å¦‚æœæ•°ç»„ä¸­åŒ…å«å¯¹è±¡ï¼Œå¯¹è¿™äº›å¯¹è±¡è¿›è¡Œæ’åº
                if (hasObjects && !hasArrays && !hasPrimitives) {
                    return sortedArray.sort((a, b) => {
                        return compareObjectsForSort(a, b);
                    });
                }

                // å¦‚æœæ•°ç»„ä¸­åªæœ‰åŸºæœ¬ç±»å‹ï¼Œè¿›è¡Œç®€å•æ’åº
                if (hasPrimitives && !hasObjects && !hasArrays) {
                    return sortedArray.sort((a, b) => {
                        return comparePrimitivesForSort(a, b);
                    });
                }

                // æ··åˆç±»å‹æ•°ç»„ï¼ŒæŒ‰ç±»å‹åˆ†ç»„åæ’åº
                return sortedArray.sort((a, b) => {
                    // å…ˆæŒ‰ç±»å‹æ’åºï¼šnull < primitive < array < object
                    const typeOrderA = getTypeOrder(a);
                    const typeOrderB = getTypeOrder(b);

                    if (typeOrderA !== typeOrderB) {
                        return typeOrderA - typeOrderB;
                    }

                    // åŒç±»å‹å†æŒ‰å€¼æ’åº
                    if (typeof a === 'object' && a !== null && !Array.isArray(a)) {
                        return compareObjectsForSort(a, b);
                    } else {
                        return comparePrimitivesForSort(a, b);
                    }
                });
            }

            // å¯¹å¯¹è±¡çš„é”®è¿›è¡Œæ’åºï¼Œå¹¶é€’å½’å¤„ç†æ¯ä¸ªå€¼
            const sorted = {};
            const keys = Object.keys(obj).sort();
            keys.forEach(key => {
                sorted[key] = sortObjectKeys(obj[key]);
            });

            return sorted;
        }

        function getTypeOrder(value) {
            if (value === null) return 0;
            if (typeof value !== 'object') return 1;
            if (Array.isArray(value)) return 2;
            return 3; // object
        }

        function compareObjectsForSort(a, b) {
            // ä¸ºå¯¹è±¡ç”Ÿæˆæ’åºé”®ï¼šç»“åˆå±æ€§åå’Œå€¼
            const getSortKey = (obj) => {
                const keys = Object.keys(obj).sort();
                const keyValuePairs = keys.map(key => {
                    const value = obj[key];
                    let valueStr;
                    if (typeof value === 'object' && value !== null) {
                        valueStr = JSON.stringify(value);
                    } else {
                        valueStr = String(value);
                    }
                    return `${key}:${valueStr}`;
                });
                return keyValuePairs.join('|');
            };

            const keyA = getSortKey(a);
            const keyB = getSortKey(b);
            return keyA.localeCompare(keyB);
        }

        function comparePrimitivesForSort(a, b) {
            // å¤„ç†nullå€¼
            if (a === null && b === null) return 0;
            if (a === null) return -1;
            if (b === null) return 1;

            // åŒç±»å‹æ¯”è¾ƒ
            if (typeof a === typeof b) {
                if (typeof a === 'string') {
                    return a.localeCompare(b);
                }
                if (typeof a === 'number') {
                    return a - b;
                }
                if (typeof a === 'boolean') {
                    return a === b ? 0 : (a ? 1 : -1);
                }
            }

            // ä¸åŒç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²æ¯”è¾ƒ
            return String(a).localeCompare(String(b));
        }

        // **æ·»åŠ å·®å¼‚è¿‡æ»¤å‡½æ•°**
        function filterIgnoredDifferences(differences) {
            return differences.filter(diff => {
                // æ£€æŸ¥å·®å¼‚å€¼æ˜¯å¦åŒ…å« [IGNORED] æ ‡è®°
                const isIgnored = (diff.value1 && typeof diff.value1 === 'string' && diff.value1.includes('[IGNORED]')) ||
                    (diff.value2 && typeof diff.value2 === 'string' && diff.value2.includes('[IGNORED]'));

                if (isIgnored) {
                    console.log(`å¿½ç•¥å·®å¼‚: è·¯å¾„ "${diff.path}" åŒ…å« [IGNORED] æ ‡è®°`);
                    return false;
                }

                // æ£€æŸ¥è·¯å¾„æ˜¯å¦åœ¨å¿½ç•¥åˆ—è¡¨ä¸­
                const ignoredPaths = [
                    'customFormPropertyMap.travel.one.screen.city.zone',
                    'customFormPropertyMap.custom.printing.config',
                    'customFormPropertyMap.travel.one.screen.city.recommend',
                    'customFormPropertyMap.close.trigger.approval.enable'
                ];

                const shouldIgnore = ignoredPaths.some(ignoredPath => diff.path.includes(ignoredPath));
                if (shouldIgnore) {
                    console.log(`å¿½ç•¥å·®å¼‚: è·¯å¾„ "${diff.path}" åœ¨å¿½ç•¥åˆ—è¡¨ä¸­`);
                    return false;
                }

                return true;
            });
        }

        function syntaxHighlight(json, differences = [], isActual = true) {
            if (typeof json != "string") {
                json = JSON.stringify(json, undefined, 2);
            }
            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // å¦‚æœæ²¡æœ‰å·®å¼‚ï¼Œä½¿ç”¨åŸæ¥çš„é«˜äº®æ–¹å¼
            if (!differences || differences.length === 0) {
                return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                    var cls = 'json-number';
                    if (/^"/.test(match)) {
                        if (/:$/.test(match)) {
                            cls = 'json-key';
                        } else {
                            cls = 'json-string';
                        }
                    } else if (/true|false/.test(match)) {
                        cls = 'json-boolean';
                    } else if (/null/.test(match)) {
                        cls = 'json-null';
                    }
                    return '<span class="' + cls + '">' + match + '</span>';
                });
            }

            // æœ‰å·®å¼‚æ—¶ï¼Œä½¿ç”¨ç®€åŒ–çš„å·®å¼‚é«˜äº®é€»è¾‘
            const lines = json.split('\n');

            // æ·»åŠ è°ƒè¯•ä¿¡æ¯åˆ°æ§åˆ¶å°
            console.log('=== è°ƒè¯•ä¿¡æ¯ ===');
            console.log('å·®å¼‚åˆ—è¡¨:', differences);
            console.log('JSONè¡Œæ•°:', lines.length);

            // åˆ›å»ºè·¯å¾„åˆ°å€¼çš„æ˜ å°„
            const pathToValueMap = createSimplePathMapping(json);
            console.log('è·¯å¾„æ˜ å°„:', pathToValueMap);

            // **è°ƒè¯•ï¼šæ˜¾ç¤ºä¸»é”®è·¯å¾„æ˜ å°„**
            console.log('=== ä¸»é”®è·¯å¾„æ˜ å°„ ===');
            Object.keys(pathToValueMap).forEach(path => {
                if (path.includes('[') && path.includes('=')) {
                    console.log(`ä¸»é”®è·¯å¾„: "${path}" -> å€¼:`, pathToValueMap[path]);
                }
            });
            console.log('====================');

            // **è¿‡æ»¤æ‰è¢«å¿½ç•¥çš„å·®å¼‚**
            const filteredDifferences = filterIgnoredDifferences(differences);

            console.log(`è¿‡æ»¤åçš„å·®å¼‚æ•°é‡: ${filteredDifferences.length} (åŸå§‹: ${differences.length})`);

            // é«˜äº®å·®å¼‚è¡Œ
            const highlightedLines = lines.map((line, lineIndex) => {
                const processedLine = highlightSyntax(line);
                const trimmedLine = line.trim();

                // è·³è¿‡ç©ºè¡Œå’Œçº¯ç»“æ„å­—ç¬¦
                if (!trimmedLine || trimmedLine === ',' || trimmedLine === '{' || trimmedLine === '}' || trimmedLine === '[' || trimmedLine === ']') {
                    return processedLine;
                }

                // æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦åŒ…å«å·®å¼‚
                let matchedDiff = null;

                // æ£€æŸ¥æ˜¯å¦æ˜¯åŒ…å«å€¼çš„è¡Œ
                for (const diff of filteredDifferences) {
                    const diffPath = diff.path;

                    // æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦åŒ…å«è¿™ä¸ªè·¯å¾„çš„å€¼
                    if (lineContainsPathValue(line, diffPath, pathToValueMap)) {
                        matchedDiff = diff;
                        console.log(`åŒ¹é…æˆåŠŸ - è¡Œ ${lineIndex}: "${trimmedLine}" åŒ¹é…å·®å¼‚è·¯å¾„ "${diffPath}"`);
                        break;
                    }
                }

                if (matchedDiff) {
                    let highlightClass = '';
                    let borderColor = '';

                    // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸»é”®è·¯å¾„
                    const isPrimaryKeyPath = matchedDiff.path.includes('[') && matchedDiff.path.includes('=');

                    console.log(`é«˜äº®é€»è¾‘ - è·¯å¾„: "${matchedDiff.path}", æ˜¯ä¸»é”®è·¯å¾„: ${isPrimaryKeyPath}, å·®å¼‚ç±»å‹: ${matchedDiff.type}`);

                    // ç»Ÿä¸€çš„å·®å¼‚é«˜äº®é€»è¾‘
                    if (matchedDiff.type === 'value') {
                        highlightClass = isActual ? 'diff-remove-line' : 'diff-add-line';
                        borderColor = isActual ? '#dc3545' : '#28a745';
                        console.log(`åº”ç”¨å€¼å·®å¼‚é«˜äº® - ç±»: ${highlightClass}, è¾¹æ¡†è‰²: ${borderColor}`);
                    } else if (matchedDiff.type === 'add' && !isActual) {
                        highlightClass = 'diff-add-line';
                        borderColor = '#28a745';
                    } else if (matchedDiff.type === 'remove' && isActual) {
                        highlightClass = 'diff-remove-line';
                        borderColor = '#dc3545';
                    } else if (matchedDiff.type === 'type') {
                        highlightClass = 'diff-change-line';
                        borderColor = '#ffc107';
                    }

                    if (highlightClass) {
                        return `<div class="${highlightClass}" style="margin: 0 -20px; padding: 0 20px; border-left: 4px solid ${borderColor};">${processedLine}</div>`;
                    }
                }

                return processedLine;
            });

            return highlightedLines.join('\n');
        }

        function createSimplePathMapping(jsonString) {
            try {
                const obj = JSON.parse(jsonString);
                const pathToValueMap = {};

                function traverseObject(obj, path = '', parentArray = null, arrayIndex = -1) {
                    if (obj === null || typeof obj !== 'object') {
                        pathToValueMap[path] = obj;
                        return;
                    }

                    if (Array.isArray(obj)) {
                        // **ä¿®å¤ï¼šä½¿ç”¨ç»Ÿä¸€çš„ findPrimaryKey å‡½æ•°**
                        const primaryKey = findPrimaryKey(obj);

                        obj.forEach((item, index) => {
                            // **æ€»æ˜¯åˆ›å»ºç´¢å¼•è·¯å¾„**
                            const indexPath = path ? `${path}[${index}]` : `[${index}]`;
                            traverseObject(item, indexPath, obj, index);

                            // **å¦‚æœæœ‰ä¸»é”®ï¼Œä¹Ÿåˆ›å»ºä¸»é”®è·¯å¾„**
                            if (primaryKey && typeof item === 'object' && item !== null && primaryKey in item) {
                                const primaryKeyPath = path ? `${path}[${primaryKey}=${item[primaryKey]}]` : `[${primaryKey}=${item[primaryKey]}]`;
                                traverseObject(item, primaryKeyPath, obj, index);
                            }
                        });
                    } else {
                        Object.keys(obj).forEach(key => {
                            const keyPath = path ? `${path}.${key}` : key;
                            traverseObject(obj[key], keyPath);
                        });
                    }
                }

                // **ç§»é™¤é‡å¤çš„ findArrayPrimaryKey å‡½æ•°ï¼Œä½¿ç”¨ç»Ÿä¸€çš„ findPrimaryKey**

                traverseObject(obj);
                return pathToValueMap;
            } catch (e) {
                console.error('åˆ›å»ºè·¯å¾„æ˜ å°„å¤±è´¥:', e);
                return {};
            }
        }

        function lineContainsPathValue(line, targetPath, pathToValueMap) {
            const trimmedLine = line.trim();

            // è·å–ç›®æ ‡è·¯å¾„çš„å€¼
            let targetValue = pathToValueMap[targetPath];

            // **æ”¹è¿›çš„ä¸»é”®è·¯å¾„åŒ¹é…é€»è¾‘**
            if (targetValue === undefined && targetPath.includes('[') && targetPath.includes('=')) {
                // å°è¯•å¤šç§æ–¹å¼æ‰¾åˆ°åŒ¹é…çš„å€¼
                
                // æ–¹æ³•1: ç›´æ¥æŸ¥æ‰¾å¯¹åº”çš„ç´¢å¼•è·¯å¾„
                const indexPath = convertPrimaryKeyPathToIndexPath(targetPath, pathToValueMap);
                if (indexPath) {
                    targetValue = pathToValueMap[indexPath];
                    console.log(`ä¸»é”®è·¯å¾„ "${targetPath}" è½¬æ¢ä¸ºç´¢å¼•è·¯å¾„ "${indexPath}"`);
                }
                
                // æ–¹æ³•2: è§£æä¸»é”®è·¯å¾„ï¼ŒæŸ¥æ‰¾åŒ¹é…çš„å¯¹è±¡
                if (targetValue === undefined) {
                    const match = targetPath.match(/\[([^=]+)=([^\]]+)\]/);
                    if (match) {
                        const [, keyName, keyValue] = match;
                        const basePath = targetPath.substring(0, targetPath.indexOf('['));
                        
                        // æŸ¥æ‰¾æ‰€æœ‰ä»¥è¯¥åŸºç¡€è·¯å¾„å¼€å¤´çš„ç´¢å¼•è·¯å¾„
                        Object.keys(pathToValueMap).forEach(path => {
                            if (path.startsWith(basePath) && path.includes('[') && !path.includes('=')) {
                                const value = pathToValueMap[path];
                                if (value && typeof value === 'object' && value[keyName] == keyValue) {
                                    targetValue = value;
                                    console.log(`é€šè¿‡ä¸»é”®åŒ¹é…æ‰¾åˆ°å€¼ - è·¯å¾„: "${path}", ä¸»é”®: ${keyName}=${keyValue}`);
                                }
                            }
                        });
                    }
                }
            }

            if (targetValue === undefined) {
                console.log(`è·¯å¾„ "${targetPath}" æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„å€¼`);
                return false;
            }

            // **å¢å¼ºçš„ä¸»é”®è·¯å¾„å¤„ç†ï¼šæ”¯æŒæ•´ä¸ªå¯¹è±¡çš„é«˜äº®**
            if (targetPath.includes('[') && targetPath.includes('=')) {
                console.log(`å¤„ç†ä¸»é”®è·¯å¾„ "${targetPath}", ç›®æ ‡å€¼:`, targetValue);

                // å¦‚æœè·¯å¾„æŒ‡å‘æ•´ä¸ªå¯¹è±¡ï¼ˆæ²¡æœ‰å…·ä½“å­—æ®µï¼‰ï¼Œæ£€æŸ¥å¯¹è±¡å†…çš„ä»»ä½•å­—æ®µ
                if (!targetPath.includes('.', targetPath.lastIndexOf(']'))) {
                    return lineContainsAnyObjectField(line, targetValue);
                }

                // æå–è·¯å¾„çš„æœ€åä¸€éƒ¨åˆ†ï¼ˆå­—æ®µåï¼‰
                const parts = targetPath.split('.');
                const fieldName = parts[parts.length - 1];
                return lineContainsFieldValue(line, fieldName, targetValue);
            }

            // **æ”¹è¿›æ™®é€šè·¯å¾„å¤„ç†**
            let lastPart;
            if (targetPath.includes('.')) {
                const parts = targetPath.split('.');
                lastPart = parts[parts.length - 1];
                // å¦‚æœæœ€åä¸€éƒ¨åˆ†åŒ…å«æ•°ç»„ç´¢å¼•ï¼Œæå–é”®å
                if (lastPart.includes('[')) {
                    lastPart = lastPart.split('[')[0];
                }
            } else if (targetPath.includes('[')) {
                // è¿™æ˜¯æ•°ç»„å…ƒç´ ï¼Œæ£€æŸ¥æ•´ä¸ªå¯¹è±¡
                return lineContainsArrayElementValue(line, targetValue);
            } else {
                lastPart = targetPath;
            }

            return lineContainsFieldValue(line, lastPart, targetValue);
        }

        function lineContainsFieldValue(line, fieldName, targetValue) {
            const trimmedLine = line.trim();

            // **å¢å¼ºçš„å­—æ®µå€¼åŒ¹é…é€»è¾‘**
            if (typeof targetValue === 'string') {
                // è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦ä»¥ç”¨äºæ­£åˆ™è¡¨è¾¾å¼
                const escapedValue = targetValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const keyValuePattern = new RegExp(`"${fieldName}"\\s*:\\s*"${escapedValue}"[,}\\s]*$`);
                const matches = keyValuePattern.test(trimmedLine);
                console.log(`å­—ç¬¦ä¸²åŒ¹é…æ£€æŸ¥ - è¡Œ: "${trimmedLine}", å­—æ®µ: "${fieldName}", ç›®æ ‡å€¼: "${targetValue}", åŒ¹é…: ${matches}`);
                return matches;
            } else if (typeof targetValue === 'number') {
                const keyValuePattern = new RegExp(`"${fieldName}"\\s*:\\s*${targetValue}[,}\\s]*$`);
                const matches = keyValuePattern.test(trimmedLine);
                console.log(`æ•°å­—åŒ¹é…æ£€æŸ¥ - è¡Œ: "${trimmedLine}", å­—æ®µ: "${fieldName}", ç›®æ ‡å€¼: ${targetValue}, åŒ¹é…: ${matches}`);
                return matches;
            } else if (typeof targetValue === 'boolean') {
                const keyValuePattern = new RegExp(`"${fieldName}"\\s*:\\s*${targetValue}[,}\\s]*$`);
                const matches = keyValuePattern.test(trimmedLine);
                console.log(`å¸ƒå°”åŒ¹é…æ£€æŸ¥ - è¡Œ: "${trimmedLine}", å­—æ®µ: "${fieldName}", ç›®æ ‡å€¼: ${targetValue}, åŒ¹é…: ${matches}`);
                return matches;
            } else if (targetValue === null) {
                const keyValuePattern = new RegExp(`"${fieldName}"\\s*:\\s*null[,}\\s]*$`);
                const matches = keyValuePattern.test(trimmedLine);
                console.log(`nullåŒ¹é…æ£€æŸ¥ - è¡Œ: "${trimmedLine}", å­—æ®µ: "${fieldName}", ç›®æ ‡å€¼: null, åŒ¹é…: ${matches}`);
                return matches;
            }

            return false;
        }

        function lineContainsAnyObjectField(line, targetValue) {
            if (typeof targetValue !== 'object' || targetValue === null) {
                return false;
            }

            console.log(`æ£€æŸ¥å¯¹è±¡å­—æ®µåŒ¹é… - è¡Œ: "${line.trim()}", ç›®æ ‡å¯¹è±¡:`, targetValue);

            // **å¢å¼ºçš„å¯¹è±¡å­—æ®µåŒ¹é…é€»è¾‘**
            // æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦åŒ…å«ç›®æ ‡å¯¹è±¡çš„ä»»ä½•å­—æ®µ
            for (const [key, value] of Object.entries(targetValue)) {
                if (lineContainsFieldValue(line, key, value)) {
                    console.log(`å¯¹è±¡å­—æ®µåŒ¹é…æˆåŠŸ - å­—æ®µ: "${key}", å€¼:`, value);
                    return true;
                }
            }

            return false;
        }

        function highlightSyntax(line) {
            return line.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                var cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }

        // **å°† findPrimaryKey å‡½æ•°ç§»åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä¾›å¤šä¸ªå‡½æ•°ä½¿ç”¨**
        function findPrimaryKey(array) {
            if (!Array.isArray(array) || array.length === 0) {
                return null;
            }

            // **æ‰©å±•ä¸»é”®è¯†åˆ«èŒƒå›´ï¼ŒåŒ…æ‹¬æ›´å¤šå¯èƒ½çš„ä¸»é”®å­—æ®µ**
            // è·å–æ‰€æœ‰å¯èƒ½çš„ä¸»é”®å€™é€‰é¡¹
            const potentialKeys = new Set();
            array.forEach(item => {
                if (typeof item === 'object' && item !== null) {
                    Object.keys(item).forEach(key => {
                        const lowerKey = key.toLowerCase();
                        // æ‰©å±•ä¸»é”®è¯†åˆ«æ¡ä»¶
                        if (lowerKey.endsWith('id') || 
                            lowerKey.endsWith('oid') || 
                            lowerKey === 'version' ||
                            lowerKey === 'name' ||
                            lowerKey === 'code' ||
                            lowerKey === 'key' ||
                            lowerKey.includes('unique')) {
                            potentialKeys.add(key);
                        }
                    });
                }
            });

            console.log(`å¯»æ‰¾ä¸»é”® - æ•°ç»„é•¿åº¦: ${array.length}, å€™é€‰ä¸»é”®:`, Array.from(potentialKeys));

            // æŒ‰ä¼˜å…ˆçº§æ’åºå€™é€‰é¡¹
            const sortedKeys = Array.from(potentialKeys).sort((a, b) => {
                // ä¼˜å…ˆçº§ï¼šid > oid > version > name > å…¶ä»–
                const getPriority = (key) => {
                    const lowerKey = key.toLowerCase();
                    if (lowerKey === 'id') return 1;
                    if (lowerKey === 'oid') return 2;
                    if (lowerKey === 'version') return 3;
                    if (lowerKey === 'name') return 4;
                    if (lowerKey === 'code') return 5;
                    if (lowerKey === 'key') return 6;
                    if (lowerKey.endsWith('id')) return 7;
                    if (lowerKey.endsWith('oid')) return 8;
                    if (lowerKey.includes('unique')) return 9;
                    return 10;
                };

                const priorityA = getPriority(a);
                const priorityB = getPriority(b);

                if (priorityA !== priorityB) {
                    return priorityA - priorityB;
                }

                // åŒä¼˜å…ˆçº§æŒ‰é•¿åº¦æ’åºï¼ˆçŸ­çš„ä¼˜å…ˆï¼‰
                return a.length - b.length;
            });

            // æ£€æŸ¥æ¯ä¸ªå€™é€‰ä¸»é”®æ˜¯å¦å”¯ä¸€
            for (const key of sortedKeys) {
                const values = [];
                let hasNullOrUndefined = false;

                for (const item of array) {
                    if (typeof item === 'object' && item !== null && key in item) {
                        const value = item[key];
                        if (value === null || value === undefined || value === '') {
                            hasNullOrUndefined = true;
                            break;
                        }
                        values.push(value);
                    } else {
                        hasNullOrUndefined = true;
                        break;
                    }
                }

                // å¦‚æœæœ‰null/undefinedå€¼æˆ–è€…å€¼ä¸å”¯ä¸€ï¼Œè·³è¿‡è¿™ä¸ªå€™é€‰é¡¹
                if (hasNullOrUndefined) {
                    console.log(`ä¸»é”® "${key}" åŒ…å«ç©ºå€¼ï¼Œè·³è¿‡`);
                    continue;
                }

                const uniqueValues = new Set(values);
                if (uniqueValues.size === values.length && values.length > 0) {
                    console.log(`æ‰¾åˆ°æœ‰æ•ˆä¸»é”®: "${key}", å€¼:`, values);
                    return key;
                } else {
                    console.log(`ä¸»é”® "${key}" æœ‰é‡å¤å€¼ï¼Œè·³è¿‡. å”¯ä¸€å€¼æ•°é‡: ${uniqueValues.size}, æ€»æ•°é‡: ${values.length}`);
                }
            }

            console.log(`æœªæ‰¾åˆ°æœ‰æ•ˆä¸»é”®ï¼Œå°†ä½¿ç”¨ç´¢å¼•å¯¹æ¯”`);
            return null;
        }

        function compareObjects(obj1, obj2, path = '') {
            const differences = [];

            function addDiff(type, path, value1, value2) {
                differences.push({
                    type: type,
                    path: path,
                    value1: value1,
                    value2: value2
                });
            }

            function createKeyValueMap(array, primaryKey) {
                const map = new Map();
                array.forEach((item, index) => {
                    if (typeof item === 'object' && item !== null && primaryKey in item) {
                        map.set(item[primaryKey], { item, originalIndex: index });
                    }
                });
                return map;
            }

            function compareArraysByPrimaryKey(arr1, arr2, currentPath, primaryKey) {
                console.log(`ä½¿ç”¨ä¸»é”® "${primaryKey}" å¯¹æ¯”æ•°ç»„, è·¯å¾„: ${currentPath}`);

                const map1 = createKeyValueMap(arr1, primaryKey);
                const map2 = createKeyValueMap(arr2, primaryKey);

                // è·å–æ‰€æœ‰ä¸»é”®å€¼
                const allKeys = new Set([...map1.keys(), ...map2.keys()]);

                allKeys.forEach(keyValue => {
                    const itemPath = `${currentPath}[${primaryKey}=${keyValue}]`;

                    if (!map1.has(keyValue)) {
                        // åªåœ¨arr2ä¸­å­˜åœ¨
                        addDiff('add', itemPath, undefined, map2.get(keyValue).item);
                    } else if (!map2.has(keyValue)) {
                        // åªåœ¨arr1ä¸­å­˜åœ¨
                        addDiff('remove', itemPath, map1.get(keyValue).item, undefined);
                    } else {
                        // ä¸¤è¾¹éƒ½å­˜åœ¨ï¼Œæ¯”è¾ƒå†…å®¹
                        compareValues(map1.get(keyValue).item, map2.get(keyValue).item, itemPath);
                    }
                });
            }

            function compareArraysByIndex(arr1, arr2, currentPath) {
                console.log(`ä½¿ç”¨ç´¢å¼•å¯¹æ¯”æ•°ç»„, è·¯å¾„: ${currentPath}`);

                const maxLength = Math.max(arr1.length, arr2.length);
                for (let i = 0; i < maxLength; i++) {
                    const itemPath = `${currentPath}[${i}]`;
                    if (i >= arr1.length) {
                        addDiff('add', itemPath, undefined, arr2[i]);
                    } else if (i >= arr2.length) {
                        addDiff('remove', itemPath, arr1[i], undefined);
                    } else {
                        compareValues(arr1[i], arr2[i], itemPath);
                    }
                }
            }

            function compareValues(val1, val2, currentPath) {
                if (val1 === val2) return;

                if (typeof val1 !== typeof val2) {
                    addDiff('type', currentPath, typeof val1, typeof val2);
                    return;
                }

                if (val1 === null || val2 === null) {
                    addDiff('value', currentPath, val1, val2);
                    return;
                }

                if (typeof val1 === 'object') {
                    if (Array.isArray(val1) !== Array.isArray(val2)) {
                        addDiff('type', currentPath, Array.isArray(val1) ? 'array' : 'object', Array.isArray(val2) ? 'array' : 'object');
                        return;
                    }

                    if (Array.isArray(val1)) {
                        // æ•°ç»„æ¯”è¾ƒï¼šå°è¯•ä½¿ç”¨ä¸»é”®åŒ¹é…
                        const primaryKey1 = findPrimaryKey(val1);
                        const primaryKey2 = findPrimaryKey(val2);

                        // å¦‚æœä¸¤ä¸ªæ•°ç»„éƒ½æœ‰ç›¸åŒçš„ä¸»é”®ï¼Œä½¿ç”¨ä¸»é”®å¯¹æ¯”
                        if (primaryKey1 && primaryKey2 && primaryKey1 === primaryKey2) {
                            console.log(`ä¸¤ä¸ªæ•°ç»„éƒ½æœ‰ç›¸åŒä¸»é”® "${primaryKey1}"ï¼Œä½¿ç”¨ä¸»é”®å¯¹æ¯”`);
                            compareArraysByPrimaryKey(val1, val2, currentPath, primaryKey1);
                        } else {
                            console.log(`æ•°ç»„ä¸»é”®ä¸åŒ¹é…æˆ–ä¸å­˜åœ¨ (${primaryKey1} vs ${primaryKey2})ï¼Œä½¿ç”¨ç´¢å¼•å¯¹æ¯”`);
                            compareArraysByIndex(val1, val2, currentPath);
                        }
                    } else {
                        // å¯¹è±¡æ¯”è¾ƒ - å¢å¼ºå¤„ç†ç¼ºå¤±å­—æ®µ
                        const allKeys = new Set([...Object.keys(val1), ...Object.keys(val2)]);
                        allKeys.forEach(key => {
                            const keyPath = currentPath ? `${currentPath}.${key}` : key;
                            if (!(key in val1)) {
                                // val1ä¸­ç¼ºå°‘è¯¥å­—æ®µï¼Œè§†ä¸ºnull
                                addDiff('add', keyPath, null, val2[key]);
                            } else if (!(key in val2)) {
                                // val2ä¸­ç¼ºå°‘è¯¥å­—æ®µï¼Œè§†ä¸ºnull
                                addDiff('remove', keyPath, val1[key], null);
                            } else {
                                compareValues(val1[key], val2[key], keyPath);
                            }
                        });
                    }
                } else {
                    addDiff('value', currentPath, val1, val2);
                }
            }

            compareValues(obj1, obj2, path);

            // **è°ƒè¯•ï¼šè¾“å‡ºæ‰€æœ‰å·®å¼‚è·¯å¾„**
            console.log('=== æ‰€æœ‰ç”Ÿæˆçš„å·®å¼‚è·¯å¾„ ===');
            differences.forEach((diff, index) => {
                const isPrimaryKey = diff.path.includes('[') && diff.path.includes('=');
                console.log(`${index + 1}. è·¯å¾„: "${diff.path}" | ç±»å‹: ${diff.type} | æ˜¯ä¸»é”®è·¯å¾„: ${isPrimaryKey}`);
            });
            console.log('=============================');

            return differences;
        }

        function formatDifferences(differences) {
            if (differences.length === 0) {
                return '<div class="success">âœ… å®é™…å“åº”ä¸é¢„æœŸå“åº”å®Œå…¨ä¸€è‡´ï¼</div>';
            }

            let html = '<div class="error">âŒ å‘ç° ' + differences.length + ' å¤„å·®å¼‚ï¼š</div><br>';

            differences.forEach((diff, index) => {
                html += `<div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #ff5722;">`;
                html += `<strong>${index + 1}. </strong>`;
                html += `<span class="property-path">è·¯å¾„: ${diff.path || 'root'}</span><br>`;

                switch (diff.type) {
                    case 'add':
                        html += `<span class="diff-add">+ é¢„æœŸå“åº”æ–°å¢: ${JSON.stringify(diff.value2)}</span>`;
                        break;
                    case 'remove':
                        html += `<span class="diff-remove">- å®é™…å“åº”ç¼ºå¤±: ${JSON.stringify(diff.value1)}</span>`;
                        break;
                    case 'value':
                        html += `<span class="diff-remove">- å®é™…å“åº”: ${JSON.stringify(diff.value1)}</span><br>`;
                        html += `<span class="diff-add">+ é¢„æœŸå“åº”: ${JSON.stringify(diff.value2)}</span>`;
                        break;
                    case 'type':
                        html += `<span class="diff-change">ç±»å‹ä¸åŒ: å®é™…(${diff.value1}) â†’ é¢„æœŸ(${diff.value2})</span>`;
                        break;
                }
                html += '</div>';
            });

            return html;
        }

        function generateStats(obj1, obj2, differences) {
            function countProperties(obj) {
                let count = 0;
                function countRecursive(o) {
                    if (typeof o === 'object' && o !== null) {
                        if (Array.isArray(o)) {
                            count += o.length;
                            o.forEach(countRecursive);
                        } else {
                            const keys = Object.keys(o);
                            count += keys.length;
                            keys.forEach(key => countRecursive(o[key]));
                        }
                    }
                }
                countRecursive(obj);
                return count;
            }

            const stats1 = countProperties(obj1);
            const stats2 = countProperties(obj2);
            const diffCount = differences.length;
            const similarity = Math.max(0, Math.round((1 - diffCount / Math.max(stats1, stats2, 1)) * 100));

            return `
                <div class="stats">
                    <h4>ğŸ“Š å¯¹æ¯”ç»Ÿè®¡</h4>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-number">${stats1}</div>
                            <div class="stat-label">å®é™…å“åº”å±æ€§æ•°</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">${stats2}</div>
                            <div class="stat-label">é¢„æœŸå“åº”å±æ€§æ•°</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">${diffCount}</div>
                            <div class="stat-label">å·®å¼‚æ•°é‡</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">${similarity}%</div>
                            <div class="stat-label">åŒ¹é…åº¦</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function formatError(error, jsonString, responseType) {
            let errorHtml = `<div class="error">âŒ ${responseType}è§£æé”™è¯¯: ${error.message}</div>`;

            // å¤„ç†ç‰¹å®šçš„JSONè§£æé”™è¯¯
            if (error.message.includes('position')) {
                const positionMatch = error.message.match(/position (\d+)/);
                if (positionMatch) {
                    const position = parseInt(positionMatch[1]);
                    const contextStart = Math.max(0, position - 50);
                    const contextEnd = Math.min(jsonString.length, position + 50);
                    const context = jsonString.substring(contextStart, contextEnd);
                    const errorPosition = position - contextStart;

                    errorHtml += `
                        <div style="margin: 15px 0; padding: 15px; background: #ffe6e6; border: 1px solid #ff9999; border-radius: 8px;">
                            <h4 style="margin-bottom: 10px; color: #d32f2f;">ğŸ” é”™è¯¯ä½ç½®è¯¦æƒ…</h4>
                            <p style="color: #d32f2f; margin-bottom: 10px;">é”™è¯¯å‘ç”Ÿåœ¨ç¬¬ ${position} ä¸ªå­—ç¬¦å¤„</p>
                            <div style="background: #f5f5f5; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; word-break: break-all;">
                                <div style="color: #666; margin-bottom: 5px;">ä¸Šä¸‹æ–‡å†…å®¹:</div>
                                <div style="white-space: pre-wrap;">${context.substring(0, errorPosition)}<span style="background: #ff0000; color: white; padding: 1px 2px;">âš </span>${context.substring(errorPosition)}</div>
                            </div>
                        </div>
                    `;
                }
            }

            // æ£€æŸ¥æ˜¯å¦æ˜¯å› ä¸ºé¢å¤–å†…å®¹å¯¼è‡´çš„é”™è¯¯
            if (error.message.includes('Unexpected') && error.message.includes('after JSON')) {
                errorHtml += `
                    <div style="margin: 15px 0; padding: 15px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px;">
                        <h4 style="margin-bottom: 10px; color: #856404;">ğŸ’¡ å¯èƒ½çš„åŸå› </h4>
                        <p style="color: #856404; margin-bottom: 10px;">JSONåé¢å¯èƒ½åŒ…å«é¢å¤–çš„æ–‡æœ¬å†…å®¹ï¼Œå¯¼è‡´è§£æå¤±è´¥ã€‚</p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 150px; overflow-y: auto;">
                            <div style="color: #666; margin-bottom: 5px;">å®Œæ•´å†…å®¹:</div>
                            <div style="white-space: pre-wrap; word-break: break-all;">${jsonString}</div>
                        </div>
                    </div>
                `;
            }

            errorHtml += `
                <div style="margin: 15px 0; padding: 15px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 8px;">
                    <h4 style="margin-bottom: 10px; color: #1976d2;">ğŸ”§ è§£å†³å»ºè®®</h4>
                    <ul style="margin-left: 20px; color: #1976d2;">
                        <li>æ£€æŸ¥JSONæ ¼å¼æ˜¯å¦æ­£ç¡®ï¼Œç¡®ä¿æ‰€æœ‰å¤§æ‹¬å·å’Œæ–¹æ‹¬å·éƒ½åŒ¹é…</li>
                        <li>ç¡®ä¿æ‰€æœ‰å­—ç¬¦ä¸²éƒ½ç”¨åŒå¼•å·åŒ…å›´</li>
                        <li>æ£€æŸ¥æ˜¯å¦æœ‰å¤šä½™çš„é€—å·æˆ–ç¼ºå°‘é€—å·</li>
                        <li>å¦‚æœJSONåé¢æœ‰é¢å¤–æ–‡æœ¬ï¼Œè¯·åˆ é™¤æˆ–ç”¨åˆ†éš”ç¬¦åˆ†å¼€</li>
                        <li>å¦‚æœåŒ…å«è½¬ä¹‰å­—ç¬¦ï¼Œè¯·ç¡®ä¿è½¬ä¹‰æ ¼å¼æ­£ç¡®</li>
                    </ul>
                </div>
            `;

            return errorHtml;
        }

        function parseAndCompare() {
            const inputText = document.getElementById('comparisonInput').value.trim();

            if (!inputText) {
                showToast('è¯·è¾“å…¥å¯¹æ¯”ç»“æœå­—ç¬¦ä¸²', 'warning');
                return;
            }

            // æ£€æŸ¥æ•°æ®å¤§å°ï¼Œå¦‚æœè¶…è¿‡1MBä½¿ç”¨ä¼˜åŒ–æ¨¡å¼
            const inputSize = new Blob([inputText]).size;
            const isLargeData = inputSize > 1024 * 1024; // 1MB
            
            if (isLargeData) {
                showToast('ğŸ”„ æ£€æµ‹åˆ°å¤§æ•°æ®ï¼Œå¯ç”¨æ€§èƒ½ä¼˜åŒ–æ¨¡å¼...', 'info', 2000);
                parseAndCompareLarge(inputText, inputSize);
            } else {
                // æ˜¾ç¤ºå¼€å§‹è§£æçš„toast
                showToast('ğŸ”„ å¼€å§‹è§£æJSONæ•°æ®...', 'info', 2000);
                
                // ä½¿ç”¨setTimeoutè®©toastæœ‰æ—¶é—´æ˜¾ç¤ºï¼Œç„¶åå¼€å§‹è§£æ
                setTimeout(() => {
                    parseAndCompareNormal(inputText);
                }, 200);
            }
        }

        // ä¼˜åŒ–åçš„å¤§æ•°æ®å¤„ç†å‡½æ•°
        function parseAndCompareLarge(inputText, inputSize) {
            // åˆ›å»ºè¿›åº¦æŒ‡ç¤ºå™¨
            const progressContainer = document.createElement('div');
            progressContainer.id = 'progress-container';
            progressContainer.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10000;
                min-width: 300px;
                text-align: center;
            `;
            
            progressContainer.innerHTML = `
                <h3 style="margin-bottom: 20px; color: #333;">ğŸš€ å¤„ç†å¤§æ•°æ®ä¸­...</h3>
                <div style="background: #f0f0f0; height: 20px; border-radius: 10px; overflow: hidden; margin-bottom: 15px;">
                    <div id="progress-bar" style="height: 100%; background: linear-gradient(90deg, #4CAF50, #45a049); width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="progress-text" style="color: #666; font-size: 14px;">å‡†å¤‡ä¸­...</div>
                <div style="margin-top: 15px; font-size: 12px; color: #999;">
                    æ•°æ®å¤§å°: ${(inputSize / 1024 / 1024).toFixed(2)} MB
                </div>
            `;
            
            document.body.appendChild(progressContainer);
            
            // ä½¿ç”¨ requestIdleCallback è¿›è¡Œåˆ†å—å¤„ç†
            const tasks = [];
            let currentProgress = 0;
            
            const updateProgress = (step, total, message) => {
                currentProgress = (step / total) * 100;
                const progressBar = document.getElementById('progress-bar');
                const progressText = document.getElementById('progress-text');
                if (progressBar) progressBar.style.width = currentProgress + '%';
                if (progressText) progressText.textContent = message;
            };
            
            // åˆ†æ­¥éª¤å¤„ç†
            const processSteps = [
                {
                    name: 'è§£æè¾“å…¥æ–‡æœ¬...',
                    fn: () => parseComparisonResult(inputText)
                },
                {
                    name: 'å¤„ç†è½¬ä¹‰å­—ç¬¦...',
                    fn: (parseResult) => {
                        return {
                            actualResponse: unescapeJSONOptimized(parseResult.actualResponse),
                            expectedResponse: unescapeJSONOptimized(parseResult.expectedResponse),
                            originalRecordedResponse: unescapeJSONOptimized(parseResult.originalRecordedResponse),
                            parseResult
                        };
                    }
                },
                {
                    name: 'è§£æJSONå¯¹è±¡...',
                    fn: (data) => {
                        const actualObj = JSON.parse(data.actualResponse);
                        const expectedObj = JSON.parse(data.expectedResponse);
                        const originalObj = JSON.parse(data.originalRecordedResponse);
                        return { actualObj, expectedObj, originalObj, parseResult: data.parseResult };
                    }
                },
                {
                    name: 'æ’åºå¯¹è±¡é”®...',
                    fn: (data) => {
                        return {
                            sortedActual: sortObjectKeysOptimized(data.actualObj),
                            sortedExpected: sortObjectKeysOptimized(data.expectedObj),
                            sortedOriginal: sortObjectKeysOptimized(data.originalObj),
                            parseResult: data.parseResult
                        };
                    }
                },
                {
                    name: 'æ¯”è¾ƒå·®å¼‚...',
                    fn: (data) => {
                        const differences = compareObjectsOptimized(data.sortedActual, data.sortedExpected);
                        const filteredDifferences = filterIgnoredDifferences(differences);
                        return { ...data, differences, filteredDifferences };
                    }
                },
                {
                    name: 'ç”Ÿæˆæ˜¾ç¤ºç»“æœ...',
                    fn: (data) => {
                        const formattedActual = JSON.stringify(data.sortedActual, null, 2);
                        const formattedExpected = JSON.stringify(data.sortedExpected, null, 2);
                        const formattedOriginal = JSON.stringify(data.sortedOriginal, null, 2);
                        
                        return {
                            ...data,
                            formattedActual,
                            formattedExpected,
                            formattedOriginal
                        };
                    }
                }
            ];
            
            let stepIndex = 0;
            let stepData = null;
            
            const processNextStep = () => {
                if (stepIndex >= processSteps.length) {
                    // å®Œæˆæ‰€æœ‰æ­¥éª¤
                    finalizeLargeDataProcessing(stepData);
                    return;
                }
                
                const step = processSteps[stepIndex];
                updateProgress(stepIndex, processSteps.length, step.name);
                
                // ä½¿ç”¨ setTimeout è®©æµè§ˆå™¨æœ‰æ—¶é—´æ›´æ–°UI
                setTimeout(() => {
                    try {
                        stepData = step.fn(stepData);
                        stepIndex++;
                        
                        // ä½¿ç”¨ requestIdleCallback æˆ– setTimeout ç»§ç»­ä¸‹ä¸€æ­¥
                        if (window.requestIdleCallback) {
                            requestIdleCallback(processNextStep, { timeout: 1000 });
                        } else {
                            setTimeout(processNextStep, 10);
                        }
                    } catch (error) {
                        console.error('å¤„ç†æ­¥éª¤å¤±è´¥:', error);
                        showToast('âŒ å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯', 'error');
                        document.body.removeChild(progressContainer);
                    }
                }, 10);
            };
            
            // å¼€å§‹å¤„ç†
            processNextStep();
        }
        
        // å®Œæˆå¤§æ•°æ®å¤„ç†
        function finalizeLargeDataProcessing(data) {
            const progressContainer = document.getElementById('progress-container');
            if (progressContainer) {
                document.body.removeChild(progressContainer);
            }
            
            // æ˜¾ç¤ºè§£æä¿¡æ¯
            const parsingHtml = `
                <div class="parsing-info">
                    <h4>âœ… å¤§æ•°æ®è§£ææˆåŠŸ</h4>
                    <p><strong>å®é™…å“åº”é•¿åº¦:</strong> ${data.parseResult.actualResponse.length} å­—ç¬¦</p>
                    <p><strong>é¢„æœŸå“åº”é•¿åº¦:</strong> ${data.parseResult.expectedResponse.length} å­—ç¬¦</p>
                    <p><strong>åŸå§‹å½•åˆ¶å“åº”é•¿åº¦:</strong> ${data.parseResult.originalRecordedResponse.length} å­—ç¬¦</p>
                    <p><strong>æ€§èƒ½ä¼˜åŒ–:</strong> å·²å¯ç”¨å¤§æ•°æ®ä¼˜åŒ–æ¨¡å¼</p>
                </div>
            `;
            document.getElementById('parsing-info').innerHTML = parsingHtml;
            
            // ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨æ˜¾ç¤ºç»“æœ
            displayLargeDataResults(data);
            
            // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
            document.getElementById('comparison-stats').innerHTML = generateStats(data.sortedActual, data.sortedExpected, data.filteredDifferences);
            
            // æ˜¾ç¤ºå·®å¼‚æŠ¥å‘Š
            const simplifiedDiffReport = data.filteredDifferences.length === 0 ?
                '<div class="success">âœ… å®é™…å“åº”ä¸é¢„æœŸå“åº”å®Œå…¨ä¸€è‡´ï¼</div>' :
                `<div class="error">âŒ å‘ç° ${data.filteredDifferences.length} å¤„å·®å¼‚ï¼Œå·²åœ¨ä¸Šæ–¹æ ¼å¼åŒ–ç»“æœä¸­ç”¨é¢œè‰²é«˜äº®æ ‡æ³¨</div>`;
            document.getElementById('diff-report').innerHTML = simplifiedDiffReport;
            
            // æ˜¾ç¤ºå®Œæˆè§£æçš„toast
            if (data.filteredDifferences.length === 0) {
                showToast('âœ… å¤§æ•°æ®è§£æå®Œæˆï¼å“åº”å®Œå…¨ä¸€è‡´', 'success');
            } else {
                showToast(`âš ï¸ å¤§æ•°æ®è§£æå®Œæˆï¼å‘ç° ${data.filteredDifferences.length} å¤„å·®å¼‚`, 'warning');
            }
        }

        // åŸå§‹çš„æ­£å¸¸æ•°æ®å¤„ç†å‡½æ•°
        function parseAndCompareNormal(inputText) {
            try {
                // è§£æè¾“å…¥æ–‡æœ¬
                const parseResult = parseComparisonResult(inputText);

                if (!parseResult.parseSuccess) {
                    showToast('âŒ è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥è¾“å…¥æ ¼å¼', 'error');
                    const errorHtml = `
                        <div class="parsing-info">
                            <h4>âŒ è§£æå¤±è´¥</h4>
                            <div class="error">
                                ${parseResult.errors.join('<br>')}
                            </div>
                            <p style="margin-top: 15px; color: #666;">
                                è¯·ç¡®ä¿è¾“å…¥æ–‡æœ¬åŒ…å«"å®é™…å“åº”:"ã€"é¢„æœŸå“åº”:"å’Œ"åŸå§‹å½•åˆ¶å“åº”:"éƒ¨åˆ†
                            </p>
                        </div>
                    `;
                    document.getElementById('parsing-info').innerHTML = errorHtml;
                    document.getElementById('actual-result').innerHTML = '';
                    document.getElementById('expected-result').innerHTML = '';
                    document.getElementById('original-recorded-result').innerHTML = '';
                    document.getElementById('diff-report').innerHTML = '';
                    document.getElementById('comparison-stats').innerHTML = '';
                    return;
                }

                // æ˜¾ç¤ºè§£æä¿¡æ¯
                const parsingHtml = `
                    <div class="parsing-info">
                        <h4>âœ… è§£ææˆåŠŸ</h4>
                        <p><strong>å®é™…å“åº”é•¿åº¦:</strong> ${parseResult.actualResponse.length} å­—ç¬¦</p>
                        <p><strong>é¢„æœŸå“åº”é•¿åº¦:</strong> ${parseResult.expectedResponse.length} å­—ç¬¦</p>
                        <p><strong>åŸå§‹å½•åˆ¶å“åº”é•¿åº¦:</strong> ${parseResult.originalRecordedResponse.length} å­—ç¬¦</p>
                        <details style="margin-top: 10px;">
                            <summary style="cursor: pointer; color: #4CAF50; font-weight: bold;">æŸ¥çœ‹åŸå§‹JSONå­—ç¬¦ä¸²</summary>
                            <div style="margin-top: 10px;">
                                <p><strong>å®é™…å“åº”åŸæ–‡:</strong></p>
                                <div class="extracted-json">${parseResult.actualResponse}</div>
                                <p><strong>é¢„æœŸå“åº”åŸæ–‡:</strong></p>
                                <div class="extracted-json">${parseResult.expectedResponse}</div>
                                <p><strong>åŸå§‹å½•åˆ¶å“åº”åŸæ–‡:</strong></p>
                                <div class="extracted-json">${parseResult.originalRecordedResponse}</div>
                            </div>
                        </details>
                    </div>
                `;
                document.getElementById('parsing-info').innerHTML = parsingHtml;

                // å»é™¤è½¬ä¹‰å­—ç¬¦å¹¶è§£æJSON
                const unescapedActual = unescapeJSON(parseResult.actualResponse);
                const unescapedExpected = unescapeJSON(parseResult.expectedResponse);
                const unescapedOriginal = unescapeJSON(parseResult.originalRecordedResponse);

                let actualObj, expectedObj, originalObj;

                // å°è¯•è§£æå®é™…å“åº”
                try {
                    actualObj = JSON.parse(unescapedActual);
                    console.log('å®é™…å“åº”è§£ææˆåŠŸ');
                } catch (error) {
                    console.log('å®é™…å“åº”è§£æå¤±è´¥:', error.message);
                    console.log('å®é™…å“åº”å†…å®¹:', unescapedActual);
                    
                    // **æ–°å¢ï¼šå¦‚æœç¬¬ä¸€æ¬¡è§£æå¤±è´¥ï¼Œå°è¯•è¿›ä¸€æ­¥å¤„ç†**
                    console.log('å°è¯•å¯¹å®é™…å“åº”è¿›è¡Œè¿›ä¸€æ­¥å¤„ç†...');
                    try {
                        // å†æ¬¡è°ƒç”¨unescapeJSONï¼Œå¯èƒ½éœ€è¦å¤šæ¬¡å¤„ç†
                        const doubleUnescapedActual = unescapeJSON(unescapedActual);
                        console.log('å®é™…å“åº”äºŒæ¬¡å¤„ç†ç»“æœ:', doubleUnescapedActual.substring(0, 100));
                        actualObj = JSON.parse(doubleUnescapedActual);
                        console.log('å®é™…å“åº”äºŒæ¬¡å¤„ç†åè§£ææˆåŠŸ');
                    } catch (secondError) {
                        console.log('å®é™…å“åº”äºŒæ¬¡å¤„ç†ä¹Ÿå¤±è´¥:', secondError.message);
                        showToast('âŒ å®é™…å“åº”JSONæ ¼å¼é”™è¯¯', 'error');
                        document.getElementById('actual-result').innerHTML = formatError(error, unescapedActual, 'å®é™…å“åº”');
                        document.getElementById('expected-result').innerHTML = '<div class="error">ç­‰å¾…å®é™…å“åº”è§£ææˆåŠŸåè¿›è¡Œå¯¹æ¯”</div>';
                        document.getElementById('original-recorded-result').innerHTML = '<div class="error">ç­‰å¾…å®é™…å“åº”è§£ææˆåŠŸåè¿›è¡Œå¯¹æ¯”</div>';
                        document.getElementById('diff-report').innerHTML = '<div class="error">æ— æ³•è¿›è¡Œå¯¹æ¯”ï¼Œè¯·å…ˆä¿®å¤å®é™…å“åº”çš„JSONæ ¼å¼</div>';
                        document.getElementById('comparison-stats').innerHTML = '';
                        return;
                    }
                }

                // å°è¯•è§£æé¢„æœŸå“åº”
                try {
                    expectedObj = JSON.parse(unescapedExpected);
                    console.log('é¢„æœŸå“åº”è§£ææˆåŠŸ');
                } catch (error) {
                    console.log('é¢„æœŸå“åº”è§£æå¤±è´¥:', error.message);
                    console.log('é¢„æœŸå“åº”å†…å®¹:', unescapedExpected);
                    
                    // **æ–°å¢ï¼šå¦‚æœç¬¬ä¸€æ¬¡è§£æå¤±è´¥ï¼Œå°è¯•è¿›ä¸€æ­¥å¤„ç†**
                    console.log('å°è¯•å¯¹é¢„æœŸå“åº”è¿›è¡Œè¿›ä¸€æ­¥å¤„ç†...');
                    try {
                        // å†æ¬¡è°ƒç”¨unescapeJSONï¼Œå¯èƒ½éœ€è¦å¤šæ¬¡å¤„ç†
                        const doubleUnescapedExpected = unescapeJSON(unescapedExpected);
                        console.log('é¢„æœŸå“åº”äºŒæ¬¡å¤„ç†ç»“æœ:', doubleUnescapedExpected.substring(0, 100));
                        expectedObj = JSON.parse(doubleUnescapedExpected);
                        console.log('é¢„æœŸå“åº”äºŒæ¬¡å¤„ç†åè§£ææˆåŠŸ');
                    } catch (secondError) {
                        console.log('é¢„æœŸå“åº”äºŒæ¬¡å¤„ç†ä¹Ÿå¤±è´¥:', secondError.message);
                        showToast('âŒ é¢„æœŸå“åº”JSONæ ¼å¼é”™è¯¯', 'error');
                        document.getElementById('expected-result').innerHTML = formatError(error, unescapedExpected, 'é¢„æœŸå“åº”');
                        document.getElementById('actual-result').innerHTML = '<div class="success">å®é™…å“åº”è§£ææˆåŠŸ</div>';
                        document.getElementById('original-recorded-result').innerHTML = '<div class="success">åŸå§‹å½•åˆ¶å“åº”è§£ææˆåŠŸ</div>';
                        document.getElementById('diff-report').innerHTML = '<div class="error">æ— æ³•è¿›è¡Œå¯¹æ¯”ï¼Œè¯·å…ˆä¿®å¤é¢„æœŸå“åº”çš„JSONæ ¼å¼</div>';
                        document.getElementById('comparison-stats').innerHTML = '';
                        return;
                    }
                }

                // å°è¯•è§£æåŸå§‹å½•åˆ¶å“åº”
                try {
                    originalObj = JSON.parse(unescapedOriginal);
                    console.log('åŸå§‹å½•åˆ¶å“åº”è§£ææˆåŠŸ');
                } catch (error) {
                    console.log('åŸå§‹å½•åˆ¶å“åº”è§£æå¤±è´¥:', error.message);
                    console.log('åŸå§‹å½•åˆ¶å“åº”å†…å®¹:', unescapedOriginal);
                    
                    // **æ–°å¢ï¼šå¦‚æœç¬¬ä¸€æ¬¡è§£æå¤±è´¥ï¼Œå°è¯•è¿›ä¸€æ­¥å¤„ç†**
                    console.log('å°è¯•å¯¹åŸå§‹å½•åˆ¶å“åº”è¿›è¡Œè¿›ä¸€æ­¥å¤„ç†...');
                    try {
                        // å†æ¬¡è°ƒç”¨unescapeJSONï¼Œå¯èƒ½éœ€è¦å¤šæ¬¡å¤„ç†
                        const doubleUnescapedOriginal = unescapeJSON(unescapedOriginal);
                        console.log('åŸå§‹å½•åˆ¶å“åº”äºŒæ¬¡å¤„ç†ç»“æœ:', doubleUnescapedOriginal.substring(0, 100));
                        originalObj = JSON.parse(doubleUnescapedOriginal);
                        console.log('åŸå§‹å½•åˆ¶å“åº”äºŒæ¬¡å¤„ç†åè§£ææˆåŠŸ');
                    } catch (secondError) {
                        console.log('åŸå§‹å½•åˆ¶å“åº”äºŒæ¬¡å¤„ç†ä¹Ÿå¤±è´¥:', secondError.message);
                        showToast('âŒ åŸå§‹å½•åˆ¶å“åº”JSONæ ¼å¼é”™è¯¯', 'error');
                        document.getElementById('original-recorded-result').innerHTML = formatError(error, unescapedOriginal, 'åŸå§‹å½•åˆ¶å“åº”');
                        document.getElementById('actual-result').innerHTML = '<div class="success">å®é™…å“åº”è§£ææˆåŠŸ</div>';
                        document.getElementById('expected-result').innerHTML = '<div class="success">é¢„æœŸå“åº”è§£ææˆåŠŸ</div>';
                        document.getElementById('diff-report').innerHTML = '<div class="error">æ— æ³•è¿›è¡Œå¯¹æ¯”ï¼Œè¯·å…ˆä¿®å¤åŸå§‹å½•åˆ¶å“åº”çš„JSONæ ¼å¼</div>';
                        document.getElementById('comparison-stats').innerHTML = '';
                        return;
                    }
                }

                // ä¸‰ä¸ªJSONéƒ½è§£ææˆåŠŸï¼Œè¿›è¡Œå¯¹æ¯”
                const sortedActual = sortObjectKeys(actualObj);
                const sortedExpected = sortObjectKeys(expectedObj);
                const sortedOriginal = sortObjectKeys(originalObj);

                // æ¯”è¾ƒå·®å¼‚
                const differences = compareObjects(sortedActual, sortedExpected);

                // **è¿‡æ»¤æ‰è¢«å¿½ç•¥çš„å·®å¼‚**
                const filteredDifferences = filterIgnoredDifferences(differences);

                console.log(`ä¸»è¦æ¯”è¾ƒé€»è¾‘ - åŸå§‹å·®å¼‚æ•°é‡: ${differences.length}, è¿‡æ»¤åå·®å¼‚æ•°é‡: ${filteredDifferences.length}`);

                // æ ¼å¼åŒ–æ˜¾ç¤ºï¼ˆå¸¦å·®å¼‚é«˜äº®ï¼‰
                const formattedActual = JSON.stringify(sortedActual, null, 2);
                const formattedExpected = JSON.stringify(sortedExpected, null, 2);
                const formattedOriginal = JSON.stringify(sortedOriginal, null, 2);

                document.getElementById('actual-result').innerHTML = syntaxHighlight(formattedActual, filteredDifferences, true);
                document.getElementById('expected-result').innerHTML = syntaxHighlight(formattedExpected, filteredDifferences, false);
                document.getElementById('original-recorded-result').innerHTML = syntaxHighlight(formattedOriginal, filteredDifferences, false);

                // **åˆå§‹åŒ–åŒæ­¥æ»šåŠ¨åŠŸèƒ½**
                setTimeout(() => {
                    initSyncScroll();
                }, 100);

                // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯ï¼ˆä½¿ç”¨è¿‡æ»¤åçš„å·®å¼‚ï¼‰
                document.getElementById('comparison-stats').innerHTML = generateStats(sortedActual, sortedExpected, filteredDifferences);

                // æ˜¾ç¤ºå·®å¼‚æŠ¥å‘Šï¼ˆç®€åŒ–ç‰ˆï¼Œä½¿ç”¨è¿‡æ»¤åçš„å·®å¼‚ï¼‰
                const simplifiedDiffReport = filteredDifferences.length === 0 ?
                    '<div class="success">âœ… å®é™…å“åº”ä¸é¢„æœŸå“åº”å®Œå…¨ä¸€è‡´ï¼</div>' :
                    `<div class="error">âŒ å‘ç° ${filteredDifferences.length} å¤„å·®å¼‚ï¼Œå·²åœ¨ä¸Šæ–¹æ ¼å¼åŒ–ç»“æœä¸­ç”¨é¢œè‰²é«˜äº®æ ‡æ³¨
                    <br><br>
                    <div style="font-size: 0.9em; color: #666; margin-top: 10px;">
                        <div style="margin: 5px 0;">ğŸ”´ <span style="background: #f8d7da; padding: 2px 6px; border-radius: 3px;">çº¢è‰²èƒŒæ™¯</span> = å®é™…å“åº”ä¸­çš„å·®å¼‚å€¼</div>
                        <div style="margin: 5px 0;">ğŸŸ¢ <span style="background: #d4edda; padding: 2px 6px; border-radius: 3px;">ç»¿è‰²èƒŒæ™¯</span> = é¢„æœŸå“åº”ä¸­çš„å·®å¼‚å€¼</div>
                        <div style="margin: 5px 0;">ğŸŸ¡ <span style="background: #fff3cd; padding: 2px 6px; border-radius: 3px;">é»„è‰²èƒŒæ™¯</span> = ç±»å‹å·®å¼‚</div>
                    </div>
                    </div>`;

                document.getElementById('diff-report').innerHTML = simplifiedDiffReport;

                // æ˜¾ç¤ºå®Œæˆè§£æçš„toast
                if (filteredDifferences.length === 0) {
                    showToast('âœ… è§£æå®Œæˆï¼å“åº”å®Œå…¨ä¸€è‡´', 'success');
                } else {
                    showToast(`âš ï¸ è§£æå®Œæˆï¼å‘ç° ${filteredDifferences.length} å¤„å·®å¼‚`, 'warning');
                }

            } catch (error) {
                showToast('âŒ è§£æè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯', 'error');
                const errorMsg = `<div class="error">âŒ æœªçŸ¥é”™è¯¯: ${error.message}</div>`;
                document.getElementById('actual-result').innerHTML = errorMsg;
                document.getElementById('expected-result').innerHTML = errorMsg;
                document.getElementById('original-recorded-result').innerHTML = errorMsg;
                document.getElementById('diff-report').innerHTML = errorMsg;
                document.getElementById('comparison-stats').innerHTML = '';
            }
        }

        function clearAll() {
            document.getElementById('comparisonInput').value = '';
            document.getElementById('parsing-info').innerHTML = '';
            document.getElementById('actual-result').innerHTML = '';
            document.getElementById('expected-result').innerHTML = '';
            document.getElementById('original-recorded-result').innerHTML = '';
            document.getElementById('diff-report').innerHTML = '';
            document.getElementById('comparison-stats').innerHTML = '';
            showToast('ğŸ—‘ï¸ å·²æ¸…ç©ºæ‰€æœ‰å†…å®¹', 'info', 2000);
        }

        // è‡ªåŠ¨è§£æåŠŸèƒ½
        let timeoutId;
        function autoParseAndCompare() {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                const input = document.getElementById('comparisonInput').value.trim();
                if (input) {
                    parseAndCompare();
                }
            }, 1500); // å»¶é•¿åˆ°1.5ç§’ï¼Œå› ä¸ºè¾“å…¥å¯èƒ½è¾ƒé•¿
        }

        // æ·»åŠ è¾“å…¥ç›‘å¬å™¨
        document.getElementById('comparisonInput').addEventListener('input', autoParseAndCompare);

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function (e) {
            if (e.ctrlKey && e.key === 'Enter') {
                parseAndCompare();
            } else if (e.ctrlKey && e.key === 'Delete') {
                clearAll();
            }
        });

        // æ·»åŠ åŒæ­¥æ»šåŠ¨åŠŸèƒ½
        function initSyncScroll() {
            const actualResult = document.getElementById('actual-result');
            const expectedResult = document.getElementById('expected-result');
            const originalRecordedResult = document.getElementById('original-recorded-result');

            // ä½¿ç”¨å•ä¸€çš„æ»šåŠ¨çŠ¶æ€æ ‡å¿—
            let isSyncing = false;

            function syncScroll(sourceElement, targetElements) {
                if (isSyncing) return;

                isSyncing = true;

                // è®¡ç®—æ»šåŠ¨æ¯”ä¾‹
                const scrollTop = sourceElement.scrollTop;
                const scrollHeight = sourceElement.scrollHeight;
                const clientHeight = sourceElement.clientHeight;
                const scrollPercentage = scrollHeight > clientHeight ? scrollTop / (scrollHeight - clientHeight) : 0;

                // åº”ç”¨åˆ°æ‰€æœ‰ç›®æ ‡å…ƒç´ 
                targetElements.forEach(target => {
                    if (target && target.scrollHeight > target.clientHeight) {
                        const targetScrollTop = scrollPercentage * (target.scrollHeight - target.clientHeight);
                        target.scrollTop = targetScrollTop;
                    }
                });

                // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿æ»šåŠ¨å®Œæˆåå†é‡ç½®æ ‡å¿—
                requestAnimationFrame(() => {
                    isSyncing = false;
                });
            }

            // ä¸ºæ¯ä¸ªå…ƒç´ æ·»åŠ æ»šåŠ¨ç›‘å¬å™¨
            if (actualResult) {
                actualResult.addEventListener('scroll', () => {
                    syncScroll(actualResult, [expectedResult, originalRecordedResult]);
                });
            }

            if (expectedResult) {
                expectedResult.addEventListener('scroll', () => {
                    syncScroll(expectedResult, [actualResult, originalRecordedResult]);
                });
            }

            if (originalRecordedResult) {
                originalRecordedResult.addEventListener('scroll', () => {
                    syncScroll(originalRecordedResult, [actualResult, expectedResult]);
                });
            }
        }

        function convertPrimaryKeyPathToIndexPath(primaryKeyPath, pathToValueMap) {
            console.log(`å°è¯•è½¬æ¢ä¸»é”®è·¯å¾„: "${primaryKeyPath}"`);
            
            // **è§£æä¸»é”®è·¯å¾„æ ¼å¼: [keyName=value] æˆ– basePath[keyName=value]**
            const match = primaryKeyPath.match(/^(.*)?\[([^=]+)=([^\]]+)\](.*)$/);
            if (!match) {
                console.log(`ä¸»é”®è·¯å¾„æ ¼å¼æ— æ•ˆ: "${primaryKeyPath}"`);
                return null;
            }
            
            const [, basePath = '', keyName, keyValue, suffixPath = ''] = match;
            console.log(`è§£æä¸»é”®è·¯å¾„ - åŸºç¡€è·¯å¾„: "${basePath}", ä¸»é”®å: "${keyName}", ä¸»é”®å€¼: "${keyValue}", åç¼€: "${suffixPath}"`);
            
            // **æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ç´¢å¼•è·¯å¾„**
            for (const [path, value] of Object.entries(pathToValueMap)) {
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç´¢å¼•è·¯å¾„ï¼ˆåŒ…å«[æ•°å­—]ä½†ä¸åŒ…å«=ï¼‰
                if (path.includes('[') && !path.includes('=')) {
                    // æ£€æŸ¥åŸºç¡€è·¯å¾„æ˜¯å¦åŒ¹é…
                    if (basePath && !path.startsWith(basePath)) {
                        continue;
                    }
                    
                    // æå–ç´¢å¼•éƒ¨åˆ†
                    const indexMatch = path.match(/\[(\d+)\]/);
                    if (!indexMatch) {
                        continue;
                    }
                    
                    // æ£€æŸ¥åç¼€è·¯å¾„
                    const expectedSuffixStart = path.indexOf(']') + 1;
                    const actualSuffix = path.substring(expectedSuffixStart);
                    if (suffixPath && actualSuffix !== suffixPath) {
                        continue;
                    }
                    
                    // è·å–è¯¥è·¯å¾„å¯¹åº”çš„å€¼
                    const pathValue = pathToValueMap[path];
                    
                    // **æ£€æŸ¥å€¼æ˜¯å¦åŒ¹é…ä¸»é”®æ¡ä»¶**
                    if (pathValue && typeof pathValue === 'object' && pathValue !== null) {
                        // å¯¹äºå¯¹è±¡ï¼Œæ£€æŸ¥ä¸»é”®å­—æ®µæ˜¯å¦åŒ¹é…
                        if (pathValue[keyName] == keyValue) {
                            console.log(`æ‰¾åˆ°åŒ¹é…çš„ç´¢å¼•è·¯å¾„: "${path}" (ä¸»é”® ${keyName}=${keyValue})`);
                            return path;
                        }
                    } else if (keyName === 'index' && pathValue == keyValue) {
                        // ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœä¸»é”®åæ˜¯indexï¼Œç›´æ¥æ¯”è¾ƒå€¼
                        console.log(`æ‰¾åˆ°åŒ¹é…çš„ç´¢å¼•è·¯å¾„: "${path}" (ç´¢å¼•å€¼åŒ¹é…)`);
                        return path;
                    }
                }
            }
            
            console.log(`æœªæ‰¾åˆ°åŒ¹é…çš„ç´¢å¼•è·¯å¾„ for "${primaryKeyPath}"`);
            return null;
        }

        function lineContainsArrayElementValue(line, targetValue) {
            const trimmedLine = line.trim();

            if (typeof targetValue === 'object' && targetValue !== null) {
                // å¯¹äºå¯¹è±¡å€¼ï¼Œæ£€æŸ¥æ˜¯å¦åŒ…å«å…¶ä¸­çš„æŸä¸ªå±æ€§
                for (const [key, value] of Object.entries(targetValue)) {
                    if (lineContainsFieldValue(line, key, value)) {
                        return true;
                    }
                }
            } else {
                // å¯¹äºåŸºæœ¬ç±»å‹å€¼ï¼Œç›´æ¥æ£€æŸ¥
                const valueStr = JSON.stringify(targetValue);
                if (trimmedLine.includes(valueStr.slice(1, -1)) || trimmedLine.includes(valueStr)) {
                    return true;
                }
            }

            return false;
        }

        // **æ·»åŠ æµ‹è¯•æ¡ˆä¾‹å‡½æ•°**
        function loadTestCase() {
            const testCase = `=== IDæ˜ å°„è®°å½• ===
è¯´æ˜ï¼šç³»ç»Ÿæ£€æµ‹åˆ°IDå­—æ®µå·®å¼‚ï¼Œå·²è‡ªåŠ¨å»ºç«‹æ˜ å°„å…³ç³»è¿›è¡Œå¯¹æ¯”

ã€æ˜ å°„è¯¦æƒ…ã€‘
IDæ˜ å°„è®°å½•:
æºID: 20250703154558001 -> ç›®æ ‡ID: 20250708003158001 (å­—æ®µç±»å‹: auto-detected, è·¯å¾„: comparison-result)
æºID: 1940678386632757250 -> ç›®æ ‡ID: 1942260311079915521 (å­—æ®µç±»å‹: auto-detected, è·¯å¾„: comparison-result)

=== æ¯”è¾ƒç»“æœè¯´æ˜ ===
âœ“ å¯¹æ¯”ç»“æœï¼šå®Œå…¨ä¸€è‡´
åŸå› ï¼šå®é™…å“åº”ä¸é¢„æœŸå“åº”åœ¨æ‰€æœ‰å­—æ®µä¸Šéƒ½å®Œå…¨åŒ¹é…
æ³¨æ„ï¼šæ£€æµ‹åˆ°IDå­—æ®µå·®å¼‚ï¼Œå·²è‡ªåŠ¨åº”ç”¨IDæ˜ å°„è§„åˆ™

=== å“åº”æ•°æ® ===
å®é™…å“åº”:
{"id":"1942260311079915521","applicationBatchId":"20250708003158001","tenantId":"1283317448444624897","roleId":"check-cost-application","status":0,"type":null,"createdBy":"86cffbd6-6ec3-435c-a82a-e24bce28637f","userName":"æµ‹æµ‹å","userEmployeeId":"new10","attachmentOid":null,"errorMsg":null,"actualBatchSize":5}

é¢„æœŸå“åº”:
{"createdBy":"86cffbd6-6ec3-435c-a82a-e24bce28637f","roleId":"check-cost-application","tenantId":"1283317448444624897","userEmployeeId":"new10","attachmentOid":null,"actualBatchSize":5,"applicationBatchId":"20250703154558001","id":"1940678386632757250","type":null,"userName":"æµ‹æµ‹å","status":0,"errorMsg":null}

åŸå§‹å½•åˆ¶å“åº”:
{"id":"1933060616021368834","applicationBatchId":"20250612151540001","tenantId":"1283317448444624897","roleId":"check-cost-application","status":0,"type":null,"createdBy":"86cffbd6-6ec3-435c-a82a-e24bce28637f","userName":"æµ‹æµ‹å","userEmployeeId":"new10","attachmentOid":null,"errorMsg":null,"actualBatchSize":5}`;

            document.getElementById('comparisonInput').value = testCase;
            showToast('ğŸ“ å·²åŠ è½½æ™®é€šå­—æ®µå·®å¼‚æµ‹è¯•æ¡ˆä¾‹', 'info', 2000);
            // è‡ªåŠ¨æ‰§è¡Œå¯¹æ¯”
            setTimeout(() => {
                parseAndCompare();
            }, 100);
        }

        // **æ·»åŠ æµ‹è¯•è“è‰²é«˜äº®çš„æ¡ˆä¾‹**
        function loadBlueHighlightTestCase() {
            const testCase = `å®é™…å“åº”:
{
  "users": [
    {
      "id": "user1",
      "name": "å¼ ä¸‰",
      "age": 25,
      "email": "zhangsan@example.com"
    },
    {
      "id": "user2", 
      "name": "æå››",
      "age": 30,
      "email": "lisi@example.com"
    }
  ],
  "total": 2
}

é¢„æœŸå“åº”:
{
  "users": [
    {
      "id": "user1_modified",
      "name": "å¼ ä¸‰",
      "age": 26,
      "email": "zhangsan@example.com"
    },
    {
      "id": "user2",
      "name": "æå››ä¿®æ”¹",
      "age": 30,
      "email": "lisi@example.com"
    }
  ],
  "total": 2
}

åŸå§‹å½•åˆ¶å“åº”:
{
  "users": [
    {
      "id": "user1",
      "name": "å¼ ä¸‰",
      "age": 25,
      "email": "zhangsan@example.com"
    },
    {
      "id": "user2",
      "name": "æå››",
      "age": 30,
      "email": "lisi@example.com"
    }
  ],
  "total": 2
}`;

            document.getElementById('comparisonInput').value = testCase;
            showToast('ğŸ”‘ å·²åŠ è½½ä¸»é”®å­—æ®µå·®å¼‚æµ‹è¯•æ¡ˆä¾‹', 'info', 2000);
            // è‡ªåŠ¨æ‰§è¡Œå¯¹æ¯”
            setTimeout(() => {
                parseAndCompare();
            }, 100);
        }

        // **æ·»åŠ å¿½ç•¥å­—æ®µæµ‹è¯•çš„æ¡ˆä¾‹**
        function loadIgnoredTestCase() {
            const testCase = `"=== çœŸå®å·®å¼‚ ===
âš ï¸ è­¦å‘Šï¼šå‘ç°æ— æ³•å¿½ç•¥çš„å…³é”®å·®å¼‚ï¼Œéœ€è¦é‡ç‚¹å…³æ³¨

ã€å·®å¼‚è¯¦æƒ…ã€‘
å·®å¼‚è¯¦æƒ…:
è·¯å¾„ï¼š[1].languageValue å®é™…å€¼ï¼š\"è‹±è¯­\" é¢„æœŸå€¼ï¼šnull
è·¯å¾„ï¼š[0].languageValue å®é™…å€¼ï¼š\"ç®€ä½“ä¸­æ–‡\" é¢„æœŸå€¼ï¼šnull
è·¯å¾„ï¼š[2].languageValue å®é™…å€¼ï¼š\"æ—¥è¯­\" é¢„æœŸå€¼ï¼šnull
è·¯å¾„ï¼š[3].languageValue å®é™…å€¼ï¼š\"é˜¿æ‹‰ä¼¯è¯­\" é¢„æœŸå€¼ï¼šnull

=== å¿½ç•¥å·®å¼‚ ===
è¯´æ˜ï¼šä»¥ä¸‹å·®å¼‚å·²è¢«ç³»ç»Ÿè‡ªåŠ¨å¿½ç•¥ï¼Œä¸å½±å“æœ€ç»ˆå¯¹æ¯”ç»“æœ

ã€ç³»ç»Ÿå¿½ç•¥è§„åˆ™ã€‘
å¿½ç•¥å·®å¼‚è¯´æ˜ï¼š
- æ‰‹åŠ¨å¿½ç•¥æ ‡è®°ï¼šåŒ…å«[IGNORED]æ ‡è®°çš„å­—æ®µå·®å¼‚å·²å¿½ç•¥
ã€å­—æ®µçº§å¿½ç•¥è¯¦æƒ…ã€‘
è·¯å¾„ï¼š[0].languageValue é¢„æœŸï¼š[IGNORED]
è·¯å¾„ï¼š[1].languageValue é¢„æœŸï¼š[IGNORED]
è·¯å¾„ï¼š[2].languageValue é¢„æœŸï¼š[IGNORED]
è·¯å¾„ï¼š[3].languageValue é¢„æœŸï¼š[IGNORED]

=== IDæ˜ å°„è®°å½• ===
è¯´æ˜ï¼šç³»ç»Ÿæ£€æµ‹åˆ°IDå­—æ®µå·®å¼‚ï¼Œå·²è‡ªåŠ¨å»ºç«‹æ˜ å°„å…³ç³»è¿›è¡Œå¯¹æ¯”

ã€æ˜ å°„è¯¦æƒ…ã€‘
IDæ˜ å°„è®°å½•: æ— 

=== æ¯”è¾ƒç»“æœè¯´æ˜ ===
âœ— å¯¹æ¯”ç»“æœï¼šå­˜åœ¨å·®å¼‚
åŸå› ï¼šå‘ç°æ— æ³•å¿½ç•¥çš„çœŸå®å·®å¼‚ï¼Œéœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥
æ³¨æ„ï¼šæ£€æµ‹åˆ°IDå­—æ®µå·®å¼‚ï¼Œå·²è‡ªåŠ¨åº”ç”¨IDæ˜ å°„è§„åˆ™

=== å“åº”æ•°æ® ===
å®é™…å“åº”:
[{\"code\":\"zh_CN\",\"value\":\"ç®€ä½“ä¸­æ–‡\",\"comments\":\"ç®€ä½“ä¸­æ–‡\",\"type\":\"language\",\"languageValue\":\"ç®€ä½“ä¸­æ–‡\"},{\"code\":\"en\",\"value\":\"è‹±æ–‡\",\"comments\":\"English\",\"type\":\"language\",\"languageValue\":\"è‹±è¯­\"},{\"code\":\"ja\",\"value\":\"æ—¥è¯­\",\"comments\":\"æ—¥æœ¬èª\",\"type\":\"language\",\"languageValue\":\"æ—¥è¯­\"},{\"code\":\"ar\",\"value\":\"é˜¿æ‹‰ä¼¯è¯­\",\"comments\":\"Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\",\"type\":\"language\",\"languageValue\":\"é˜¿æ‹‰ä¼¯è¯­\"}]

é¢„æœŸå“åº”:
[{\"code\":\"zh_CN\",\"comments\":\"ç®€ä½“ä¸­æ–‡\",\"type\":\"language\",\"value\":\"ç®€ä½“ä¸­æ–‡\",\"languageValue\":\"[IGNORED]\"},{\"code\":\"en\",\"comments\":\"English\",\"type\":\"language\",\"value\":\"è‹±æ–‡\",\"languageValue\":\"[IGNORED]\"},{\"code\":\"ja\",\"comments\":\"æ—¥æœ¬èª\",\"type\":\"language\",\"value\":\"æ—¥è¯­\",\"languageValue\":\"[IGNORED]\"},{\"code\":\"ar\",\"comments\":\"Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\",\"type\":\"language\",\"value\":\"é˜¿æ‹‰ä¼¯è¯­\",\"languageValue\":\"[IGNORED]\"}]

åŸå§‹å½•åˆ¶å“åº”:
[{\"code\":\"zh_CN\",\"value\":\"ç®€ä½“ä¸­æ–‡\",\"comments\":\"ç®€ä½“ä¸­æ–‡\",\"type\":\"language\"},{\"code\":\"en\",\"value\":\"è‹±æ–‡\",\"comments\":\"English\",\"type\":\"language\"},{\"code\":\"ja\",\"value\":\"æ—¥è¯­\",\"comments\":\"æ—¥æœ¬èª\",\"type\":\"language\"},{\"code\":\"ar\",\"value\":\"é˜¿æ‹‰ä¼¯è¯­\",\"comments\":\"Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\",\"type\":\"language\"}]"`;

            document.getElementById('comparisonInput').value = testCase;
            showToast('ğŸš« å·²åŠ è½½å¿½ç•¥å­—æ®µæµ‹è¯•æ¡ˆä¾‹', 'info', 2000);
            // è‡ªåŠ¨æ‰§è¡Œå¯¹æ¯”
            setTimeout(() => {
                parseAndCompare();
            }, 100);
        }

        // ä¼˜åŒ–åçš„JSONè½¬ä¹‰å¤„ç†å‡½æ•°
        function unescapeJSONOptimized(str) {
            try {
                // ä½¿ç”¨æ›´é«˜æ•ˆçš„å­—ç¬¦ä¸²å¤„ç†
                let cleaned = str.trim();
                
                // å¿«é€Ÿæ£€æŸ¥æ˜¯å¦éœ€è¦å¤„ç†
                if (!cleaned.includes('\\')) {
                    try {
                        JSON.parse(cleaned);
                        return cleaned;
                    } catch (e) {
                        // ç»§ç»­å¤„ç†
                    }
                }
                
                // å»æ‰åŒ…è£…çš„åŒå¼•å·
                if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
                    cleaned = cleaned.slice(1, -1);
                }

                // ä½¿ç”¨å•æ¬¡éå†è¿›è¡Œæ‰€æœ‰è½¬ä¹‰å¤„ç†
                const result = cleaned.replace(/\\(u[0-9a-fA-F]{4}|[\\"/bfnrt])/g, (match, p1) => {
                    switch (p1[0]) {
                        case 'u': return String.fromCharCode(parseInt(p1.slice(1), 16));
                        case '\\': return '\\';
                        case '"': return '"';
                        case '/': return '/';
                        case 'b': return '\b';
                        case 'f': return '\f';
                        case 'n': return '\n';
                        case 'r': return '\r';
                        case 't': return '\t';
                        default: return match;
                    }
                });

                return result;
            } catch (e) {
                console.log('unescapeJSONOptimized error:', e.message);
                return str;
            }
        }

        // ä¼˜åŒ–åçš„å¯¹è±¡é”®æ’åºå‡½æ•°
        function sortObjectKeysOptimized(obj) {
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }

            if (Array.isArray(obj)) {
                // å¯¹äºå¤§æ•°ç»„ï¼Œä½¿ç”¨æ›´é«˜æ•ˆçš„æ’åºç­–ç•¥
                if (obj.length > 1000) {
                    // å¤§æ•°ç»„ä¸æ’åºï¼Œä¿æŒåŸå§‹é¡ºåºä»¥æé«˜æ€§èƒ½
                    return obj.map(item => sortObjectKeysOptimized(item));
                } else {
                    // å°æ•°ç»„æ­£å¸¸æ’åº
                    return obj.map(item => sortObjectKeysOptimized(item));
                }
            }

            // å¯¹è±¡å¤„ç† - ä½¿ç”¨æ›´é«˜æ•ˆçš„æ–¹æ³•
            const keys = Object.keys(obj);
            if (keys.length > 100) {
                // å¤§å¯¹è±¡ä½¿ç”¨åŸç”Ÿæ’åº
                keys.sort();
            } else {
                // å°å¯¹è±¡ä½¿ç”¨æ›´è¯¦ç»†çš„æ’åº
                keys.sort((a, b) => a.localeCompare(b));
            }

            const sorted = {};
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                sorted[key] = sortObjectKeysOptimized(obj[key]);
            }

            return sorted;
        }

        // ä¼˜åŒ–åçš„å¯¹è±¡æ¯”è¾ƒå‡½æ•°
        function compareObjectsOptimized(obj1, obj2, path = '') {
            const differences = [];
            const maxDifferences = 10000; // é™åˆ¶æœ€å¤§å·®å¼‚æ•°é‡

            function addDiff(type, path, value1, value2) {
                if (differences.length >= maxDifferences) {
                    return false; // è¾¾åˆ°æœ€å¤§å·®å¼‚æ•°é‡ï¼Œåœæ­¢æ·»åŠ 
                }
                differences.push({
                    type: type,
                    path: path,
                    value1: value1,
                    value2: value2
                });
                return true;
            }

            function compareValues(val1, val2, currentPath) {
                if (differences.length >= maxDifferences) {
                    return false;
                }

                if (val1 === val2) return true;

                if (typeof val1 !== typeof val2) {
                    return addDiff('type', currentPath, typeof val1, typeof val2);
                }

                if (val1 === null || val2 === null) {
                    return addDiff('value', currentPath, val1, val2);
                }

                if (typeof val1 === 'object') {
                    if (Array.isArray(val1) !== Array.isArray(val2)) {
                        return addDiff('type', currentPath, Array.isArray(val1) ? 'array' : 'object', Array.isArray(val2) ? 'array' : 'object');
                    }

                    if (Array.isArray(val1)) {
                        // æ•°ç»„æ¯”è¾ƒä¼˜åŒ–
                        const primaryKey1 = findPrimaryKeyOptimized(val1);
                        const primaryKey2 = findPrimaryKeyOptimized(val2);

                        if (primaryKey1 && primaryKey2 && primaryKey1 === primaryKey2) {
                            return compareArraysByPrimaryKeyOptimized(val1, val2, currentPath, primaryKey1);
                        } else {
                            return compareArraysByIndexOptimized(val1, val2, currentPath);
                        }
                    } else {
                        // å¯¹è±¡æ¯”è¾ƒä¼˜åŒ–
                        const keys1 = Object.keys(val1);
                        const keys2 = Object.keys(val2);
                        const allKeys = new Set([...keys1, ...keys2]);

                        for (const key of allKeys) {
                            if (differences.length >= maxDifferences) break;
                            
                            const keyPath = currentPath ? `${currentPath}.${key}` : key;
                            if (!(key in val1)) {
                                if (!addDiff('add', keyPath, null, val2[key])) break;
                            } else if (!(key in val2)) {
                                if (!addDiff('remove', keyPath, val1[key], null)) break;
                            } else {
                                if (!compareValues(val1[key], val2[key], keyPath)) break;
                            }
                        }
                    }
                } else {
                    return addDiff('value', currentPath, val1, val2);
                }

                return true;
            }

            function compareArraysByPrimaryKeyOptimized(arr1, arr2, currentPath, primaryKey) {
                const map1 = new Map();
                const map2 = new Map();

                // æ„å»ºæ˜ å°„
                for (let i = 0; i < arr1.length; i++) {
                    const item = arr1[i];
                    if (typeof item === 'object' && item !== null && primaryKey in item) {
                        map1.set(item[primaryKey], { item, originalIndex: i });
                    }
                }

                for (let i = 0; i < arr2.length; i++) {
                    const item = arr2[i];
                    if (typeof item === 'object' && item !== null && primaryKey in item) {
                        map2.set(item[primaryKey], { item, originalIndex: i });
                    }
                }

                // æ¯”è¾ƒ
                const allKeys = new Set([...map1.keys(), ...map2.keys()]);
                for (const keyValue of allKeys) {
                    if (differences.length >= maxDifferences) break;
                    
                    const itemPath = `${currentPath}[${primaryKey}=${keyValue}]`;
                    if (!map1.has(keyValue)) {
                        if (!addDiff('add', itemPath, undefined, map2.get(keyValue).item)) break;
                    } else if (!map2.has(keyValue)) {
                        if (!addDiff('remove', itemPath, map1.get(keyValue).item, undefined)) break;
                    } else {
                        if (!compareValues(map1.get(keyValue).item, map2.get(keyValue).item, itemPath)) break;
                    }
                }

                return true;
            }

            function compareArraysByIndexOptimized(arr1, arr2, currentPath) {
                const maxLength = Math.max(arr1.length, arr2.length);
                for (let i = 0; i < maxLength; i++) {
                    if (differences.length >= maxDifferences) break;
                    
                    const itemPath = `${currentPath}[${i}]`;
                    if (i >= arr1.length) {
                        if (!addDiff('add', itemPath, undefined, arr2[i])) break;
                    } else if (i >= arr2.length) {
                        if (!addDiff('remove', itemPath, arr1[i], undefined)) break;
                    } else {
                        if (!compareValues(arr1[i], arr2[i], itemPath)) break;
                    }
                }
                return true;
            }

            compareValues(obj1, obj2, path);

            if (differences.length >= maxDifferences) {
                differences.push({
                    type: 'info',
                    path: '...',
                    value1: `å·²è¾¾åˆ°æœ€å¤§å·®å¼‚æ•°é‡é™åˆ¶ (${maxDifferences})`,
                    value2: 'å¯èƒ½è¿˜æœ‰æ›´å¤šå·®å¼‚æœªæ˜¾ç¤º'
                });
            }

            return differences;
        }

        // ä¼˜åŒ–åçš„ä¸»é”®æŸ¥æ‰¾å‡½æ•°
        function findPrimaryKeyOptimized(array) {
            if (!Array.isArray(array) || array.length === 0) {
                return null;
            }

            // åªæ£€æŸ¥å‰å‡ ä¸ªå…ƒç´ æ¥ç¡®å®šä¸»é”®ï¼Œæé«˜æ€§èƒ½
            const sampleSize = Math.min(array.length, 10);
            const potentialKeys = new Set();

            for (let i = 0; i < sampleSize; i++) {
                const item = array[i];
                if (typeof item === 'object' && item !== null) {
                    Object.keys(item).forEach(key => {
                        if (key.toLowerCase().endsWith('id') || key.toLowerCase().endsWith('oid')) {
                            potentialKeys.add(key);
                        }
                    });
                }
            }

            // ä¼˜å…ˆçº§æ’åº
            const sortedKeys = Array.from(potentialKeys).sort((a, b) => {
                const lowerA = a.toLowerCase();
                const lowerB = b.toLowerCase();
                if (lowerA === 'id') return -1;
                if (lowerB === 'id') return 1;
                if (lowerA === 'oid') return -1;
                if (lowerB === 'oid') return 1;
                return a.length - b.length;
            });

            // éªŒè¯ä¸»é”®å”¯ä¸€æ€§ï¼ˆåªæ£€æŸ¥æ ·æœ¬ï¼‰
            for (const key of sortedKeys) {
                const values = new Set();
                let isValid = true;

                for (let i = 0; i < sampleSize; i++) {
                    const item = array[i];
                    if (typeof item === 'object' && item !== null && key in item) {
                        const value = item[key];
                        if (value === null || value === undefined || values.has(value)) {
                            isValid = false;
                            break;
                        }
                        values.add(value);
                    } else {
                        isValid = false;
                        break;
                    }
                }

                if (isValid) {
                    return key;
                }
            }

            return null;
        }

        // å¤§æ•°æ®ç»“æœæ˜¾ç¤ºå‡½æ•°ï¼ˆä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨ï¼‰
        function displayLargeDataResults(data) {
            const actualElement = document.getElementById('actual-result');
            const expectedElement = document.getElementById('expected-result');
            const originalElement = document.getElementById('original-recorded-result');

            // æ£€æŸ¥JSONå¤§å°
            const actualSize = data.formattedActual.length;
            const expectedSize = data.formattedExpected.length;
            const originalSize = data.formattedOriginal.length;

            // å¦‚æœJSONå¤ªå¤§ï¼Œä½¿ç”¨ç®€åŒ–æ˜¾ç¤ºï¼ˆåªæ˜¾ç¤ºæœ‰å·®å¼‚çš„éƒ¨åˆ†ï¼‰
            if (actualSize > 500000 || expectedSize > 500000 || originalSize > 500000) {
                console.log('ğŸš€ å¯ç”¨å¤§æ•°æ®ä¼˜åŒ–æ˜¾ç¤ºæ¨¡å¼ - åªæ˜¾ç¤ºæœ‰å·®å¼‚çš„å±æ€§');
                
                // åˆ›å»ºåªåŒ…å«å·®å¼‚çš„ç®€åŒ–JSON
                const simplifiedActual = createDifferenceOnlyJson(data.sortedActual, data.sortedExpected, data.filteredDifferences, true);
                const simplifiedExpected = createDifferenceOnlyJson(data.sortedExpected, data.sortedActual, data.filteredDifferences, false);
                const simplifiedOriginal = createDifferenceOnlyJson(data.sortedOriginal, data.sortedExpected, data.filteredDifferences, false);
                
                actualElement.innerHTML = createLargeDataView(simplifiedActual, data.filteredDifferences, true, 'å®é™…å“åº”');
                expectedElement.innerHTML = createLargeDataView(simplifiedExpected, data.filteredDifferences, false, 'é¢„æœŸå“åº”');
                originalElement.innerHTML = createLargeDataView(simplifiedOriginal, data.filteredDifferences, false, 'åŸå§‹å½•åˆ¶å“åº”');
            } else {
                // æ­£å¸¸æ˜¾ç¤º
                actualElement.innerHTML = syntaxHighlight(data.formattedActual, data.filteredDifferences, true);
                expectedElement.innerHTML = syntaxHighlight(data.formattedExpected, data.filteredDifferences, false);
                originalElement.innerHTML = syntaxHighlight(data.formattedOriginal, data.filteredDifferences, false);
            }

            // åˆå§‹åŒ–åŒæ­¥æ»šåŠ¨
            setTimeout(() => {
                initSyncScroll();
            }, 100);
        }

        // åˆ›å»ºåªåŒ…å«å·®å¼‚çš„JSONï¼ˆéšè—å®Œå…¨ç›¸åŒçš„å±æ€§ï¼‰
        function createDifferenceOnlyJson(sourceJson, targetJson, differences, isActual) {
            console.log(`ğŸ“Š åˆ›å»ºå·®å¼‚ä¸“ç”¨JSON - ${isActual ? 'å®é™…' : 'é¢„æœŸ/åŸå§‹'}å“åº”`);
            
            // æ£€æŸ¥è¾“å…¥å‚æ•°
            if (!sourceJson) {
                console.warn('createDifferenceOnlyJson: sourceJson is invalid:', sourceJson);
                return JSON.stringify({ "error": "âŒ æºæ•°æ®ä¸ºç©ºæˆ–æ— æ•ˆ" }, null, 2);
            }
            
            if (!differences || differences.length === 0) {
                return JSON.stringify({ "message": "âœ… æ²¡æœ‰å‘ç°å·®å¼‚ï¼Œæ‰€æœ‰å±æ€§éƒ½å®Œå…¨ç›¸åŒ" }, null, 2);
            }

            try {
                // æ”¶é›†æ‰€æœ‰å·®å¼‚è·¯å¾„
                const differencePaths = new Set();
                differences.forEach(diff => {
                    if (diff.path) {
                        differencePaths.add(diff.path);
                        // æ·»åŠ çˆ¶è·¯å¾„ä»¥ä¿æŒç»“æ„å®Œæ•´æ€§
                        const pathParts = diff.path.split('.');
                        for (let i = 1; i < pathParts.length; i++) {
                            const parentPath = pathParts.slice(0, i).join('.');
                            if (parentPath) {
                                differencePaths.add(parentPath);
                            }
                        }
                    }
                });

                console.log(`ğŸ“ æ”¶é›†åˆ° ${differencePaths.size} ä¸ªå·®å¼‚è·¯å¾„:`, Array.from(differencePaths));

                // åˆ›å»ºå¸¦çœç•¥å·çš„JSONç»“æ„
                const compactJson = createCompactJsonWithEllipsis(sourceJson, differencePaths);
                
                if (compactJson === undefined || compactJson === null) {
                    console.warn('createCompactJsonWithEllipsis returned invalid result:', compactJson);
                    return JSON.stringify({ "error": "âŒ å¤„ç†å·®å¼‚æ•°æ®æ—¶å‡ºé”™" }, null, 2);
                }
                
                return JSON.stringify(compactJson, null, 2);
            } catch (error) {
                console.error('createDifferenceOnlyJson error:', error);
                return JSON.stringify({ 
                    "error": "âŒ å¤„ç†å·®å¼‚æ•°æ®æ—¶å‡ºé”™", 
                    "details": error.message 
                }, null, 2);
            }
        }

        // åˆ›å»ºå¸¦çœç•¥å·çš„ç´§å‡‘JSONç»“æ„
        function createCompactJsonWithEllipsis(jsonObj, differencePaths, depth = 0) {
            const maxDepth = 10; // æœ€å¤§é€’å½’æ·±åº¦
            
            if (depth > maxDepth) {
                return "...æ·±åº¦è¿‡æ·±ï¼Œå·²çœç•¥";
            }
            
            if (!jsonObj || typeof jsonObj !== 'object') {
                return jsonObj;
            }

            if (Array.isArray(jsonObj)) {
                return createCompactArrayWithEllipsis(jsonObj, differencePaths);
            }

            const result = {};
            const pathsArray = Array.from(differencePaths);
            
            // è·å–å½“å‰å±‚çº§çš„å·®å¼‚è·¯å¾„
            const currentLevelPaths = pathsArray.filter(path => !path.includes('.') && !path.includes('['));
            const nestedPaths = pathsArray.filter(path => path.includes('.') || path.includes('['));
            
            // æŒ‰è·¯å¾„åˆ†ç»„å¤„ç†åµŒå¥—ç»“æ„
            const nestedGroups = {};
            nestedPaths.forEach(path => {
                let firstPart;
                if (path.includes('.')) {
                    firstPart = path.split('.')[0];
                } else if (path.includes('[')) {
                    firstPart = path.split('[')[0];
                }
                
                if (firstPart) {
                    if (!nestedGroups[firstPart]) {
                        nestedGroups[firstPart] = [];
                    }
                    
                    let remainingPath;
                    if (path.includes('.')) {
                        remainingPath = path.substring(firstPart.length + 1);
                    } else if (path.includes('[')) {
                        remainingPath = path.substring(firstPart.length);
                    }
                    
                    if (remainingPath) {
                        nestedGroups[firstPart].push(remainingPath);
                    }
                }
            });

            const allKeys = Object.keys(jsonObj);
            const differenceKeys = new Set([...currentLevelPaths, ...Object.keys(nestedGroups)]);
            const sameKeys = allKeys.filter(key => !differenceKeys.has(key));

            console.log(`å¯¹è±¡å¤„ç† - æ·±åº¦: ${depth}, æ€»å±æ€§: ${allKeys.length}, å·®å¼‚å±æ€§: ${differenceKeys.size}, ç›¸åŒå±æ€§: ${sameKeys.length}`);

            // æ·»åŠ çœç•¥å·åœ¨å¼€å¤´ï¼ˆå¦‚æœæœ‰ç›¸åŒå±æ€§ï¼‰
            if (sameKeys.length > 0) {
                const showSameKeys = sameKeys.slice(0, 3);
                result["..."] = `éšè—${sameKeys.length}ä¸ªç›¸åŒå±æ€§: [${showSameKeys.join(', ')}${sameKeys.length > 3 ? '...' : ''}]`;
            }

            // å¤„ç†æ‰€æœ‰æœ‰å·®å¼‚çš„å±æ€§
            for (const key of differenceKeys) {
                if (key in jsonObj) {
                    if (nestedGroups[key] && nestedGroups[key].length > 0) {
                        // é€’å½’å¤„ç†åµŒå¥—å¯¹è±¡
                        const nestedDifferencePaths = new Set(nestedGroups[key]);
                        result[key] = createCompactJsonWithEllipsis(jsonObj[key], nestedDifferencePaths, depth + 1);
                    } else {
                        // ç›´æ¥æ˜¾ç¤ºå·®å¼‚å±æ€§
                        result[key] = jsonObj[key];
                    }
                }
            }

            return result;
        }

        // åˆ›å»ºå¸¦çœç•¥å·çš„ç´§å‡‘æ•°ç»„ç»“æ„
        function createCompactArrayWithEllipsis(arrayObj, differencePaths) {
            const result = [];
            const pathsArray = Array.from(differencePaths);
            
            // å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œç›´æ¥è¿”å›
            if (!arrayObj || arrayObj.length === 0) {
                return [];
            }
            
            // è§£ææ•°ç»„ç›¸å…³çš„è·¯å¾„
            const arrayIndices = new Set();
            const arrayPrimaryKeys = new Set();
            
            pathsArray.forEach(path => {
                if (path.startsWith('[')) {
                    const indexPart = path.substring(1, path.indexOf(']'));
                    if (indexPart.includes('=')) {
                        // ä¸»é”®è·¯å¾„ [id=123]
                        arrayPrimaryKeys.add(indexPart);
                    } else {
                        // æ•°ç»„ç´¢å¼• [0]
                        const index = parseInt(indexPart);
                        if (!isNaN(index)) {
                            arrayIndices.add(index);
                        }
                    }
                }
            });

            console.log(`æ•°ç»„å¤„ç† - æ€»å…ƒç´ : ${arrayObj.length}, ä¸»é”®å·®å¼‚: ${arrayPrimaryKeys.size}, ç´¢å¼•å·®å¼‚: ${arrayIndices.size}`);

            // å¦‚æœæœ‰ä¸»é”®å·®å¼‚ï¼Œæ˜¾ç¤ºæ‰€æœ‰ç›¸å…³çš„æ•°ç»„å…ƒç´ 
            if (arrayPrimaryKeys.size > 0) {
                const shownItems = new Set();
                
                arrayPrimaryKeys.forEach(keyValue => {
                    const [keyName, value] = keyValue.split('=');
                    const item = arrayObj.find(item => 
                        item && typeof item === 'object' && 
                        String(item[keyName]) === value
                    );
                    
                    if (item) {
                        const itemIndex = arrayObj.indexOf(item);
                        shownItems.add(itemIndex);
                        
                        // å¤„ç†è¯¥å…ƒç´ çš„åµŒå¥—å·®å¼‚
                        const nestedPaths = pathsArray
                            .filter(path => path.startsWith(`[${keyValue}]`))
                            .map(path => path.substring(`[${keyValue}]`.length + 1))
                            .filter(path => path.length > 0);
                        
                        if (nestedPaths.length > 0) {
                            result.push(createCompactJsonWithEllipsis(item, new Set(nestedPaths)));
                        } else {
                            result.push(item);
                        }
                    }
                });
                
                // æ·»åŠ çœç•¥å·è¡¨ç¤ºå…¶ä»–ç›¸åŒå…ƒç´ 
                const hiddenCount = arrayObj.length - shownItems.size;
                if (hiddenCount > 0) {
                    result.push(`...å…¶ä»–${hiddenCount}ä¸ªç›¸åŒå…ƒç´ `);
                }
            }
            // å¦‚æœæœ‰ç´¢å¼•å·®å¼‚ï¼Œæ˜¾ç¤ºæ‰€æœ‰ç›¸å…³çš„æ•°ç»„å…ƒç´ 
            else if (arrayIndices.size > 0) {
                const sortedIndices = Array.from(arrayIndices).sort((a, b) => a - b);
                
                let lastShownIndex = -1;
                
                for (const index of sortedIndices) {
                    // å¦‚æœç´¢å¼•ä¹‹é—´æœ‰é—´éš”ï¼Œæ·»åŠ çœç•¥å·
                    if (lastShownIndex >= 0 && index > lastShownIndex + 1) {
                        result.push("...");
                    }
                    
                    if (index < arrayObj.length) {
                        result.push(arrayObj[index]);
                        lastShownIndex = index;
                    }
                }
                
                // å¦‚æœæœ€åæ˜¾ç¤ºçš„ç´¢å¼•ä¸æ˜¯æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæ·»åŠ çœç•¥å·
                if (lastShownIndex >= 0 && lastShownIndex < arrayObj.length - 1) {
                    result.push("...");
                }
            }
            // å¦‚æœæ²¡æœ‰å…·ä½“çš„æ•°ç»„å·®å¼‚è·¯å¾„ï¼Œä½†æ•°ç»„æœ¬èº«åœ¨å·®å¼‚è·¯å¾„ä¸­
            else {
                // æ£€æŸ¥æ˜¯å¦æ•´ä¸ªæ•°ç»„éƒ½æœ‰å·®å¼‚
                const hasArrayDifference = pathsArray.some(path => path === '' || path === '[]');
                
                if (hasArrayDifference) {
                    // å¦‚æœæ•´ä¸ªæ•°ç»„éƒ½æœ‰å·®å¼‚ï¼Œæ˜¾ç¤ºæ‰€æœ‰å…ƒç´ 
                    return arrayObj;
                } else {
                    // å¦‚æœæ²¡æœ‰æ˜ç¡®çš„å·®å¼‚ï¼Œæ˜¾ç¤ºæ‘˜è¦
                    result.push(`...æ•°ç»„åŒ…å«${arrayObj.length}ä¸ªå…ƒç´ ï¼Œæ— æ˜ç¡®å·®å¼‚`);
                }
            }

            return result;
        }

        // åˆ›å»ºå¤§æ•°æ®è§†å›¾
        function createLargeDataView(jsonString, differences, isActual, title) {
            // æ£€æŸ¥è¾“å…¥å‚æ•°
            if (!jsonString || typeof jsonString !== 'string') {
                console.warn('createLargeDataView: jsonString is invalid:', jsonString);
                return `
                    <div style="background: #ffebee; padding: 10px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid #f44336;">
                        <div style="font-weight: bold; color: #c62828;">âš ï¸ ${title || 'æ•°æ®'} - æ•°æ®æ— æ•ˆ</div>
                        <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                            æ— æ³•æ˜¾ç¤ºæ•°æ®ï¼šè¾“å…¥ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®
                        </div>
                    </div>
                `;
            }

            const lines = jsonString.split('\n');
            const totalLines = lines.length;
            const maxDisplayLines = 1000; // æœ€å¤šæ˜¾ç¤º1000è¡Œ

            if (totalLines <= maxDisplayLines) {
                // å¦‚æœè¡Œæ•°ä¸å¤šï¼Œæ­£å¸¸æ˜¾ç¤º
                return syntaxHighlight(jsonString, differences, isActual);
            }

            // åˆ›å»ºç®€åŒ–çš„å¤´éƒ¨æç¤º
            const summary = `
                <div style="background: #f0f8ff; padding: 10px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid #2196F3;">
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <div style="font-weight: bold; color: #1976D2;">ğŸ“Š ${title} - å·®å¼‚ä¸“ç”¨è§†å›¾</div>
                        <div style="font-size: 0.9em; color: #666;">
                            å·®å¼‚æ•°é‡: <span style="color: #ff5722; font-weight: bold;">${differences.length}</span> | 
                            æ˜¾ç¤ºè¡Œæ•°: <span style="color: #2196F3; font-weight: bold;">${totalLines.toLocaleString()}</span>
                        </div>
                    </div>
                </div>
            `;

            // æ˜¾ç¤ºå‰é¢çš„è¡Œ
            const displayLines = lines.slice(0, maxDisplayLines);
            const displayJson = displayLines.join('\n');
            const highlightedJson = syntaxHighlight(displayJson, differences, isActual);

            return summary + highlightedJson + (totalLines > maxDisplayLines ? `
                <div style="background: #fff3cd; padding: 10px; border-radius: 8px; margin-top: 10px; border-left: 4px solid #ffc107;">
                    <div style="font-size: 0.9em; color: #856404;">
                        âš ï¸ å·²æˆªæ–­æ˜¾ç¤ºï¼šéšè—äº† ${(totalLines - maxDisplayLines).toLocaleString()} è¡Œå·®å¼‚æ•°æ®
                    </div>
                </div>
            ` : '');
        }
    </script>
</body>

</html>